# Nexus HAL Usage Examples

This directory contains comprehensive usage examples for the Nexus Hardware Abstraction Layer (HAL).

## Available Examples

### 1. UART Example (`nx_uart_example.c`)

Demonstrates UART interface usage including:
- Basic synchronous communication (send/receive with timeout)
- Asynchronous communication with callbacks
- Runtime baudrate switching and configuration management
- Statistics and diagnostics querying
- Power management (suspend/resume)

**Key Features Demonstrated:**
- Factory pattern for device acquisition
- Lifecycle management (init/deinit/suspend/resume)
- Synchronous and asynchronous TX/RX interfaces
- Runtime configuration changes
- Error handling and status reporting

### 2. GPIO Example (`nx_gpio_example.c`)

Demonstrates GPIO interface usage including:
- Basic output control (LED blinking)
- Input reading with pull-up/pull-down configuration
- Runtime mode switching (input â†” output)
- External interrupt (EXTI) configuration
- Managing multiple GPIO pins simultaneously

**Key Features Demonstrated:**
- Pin configuration (mode, pull, speed)
- Read/write/toggle operations
- Interrupt callbacks with priority
- Custom configuration via factory
- Multi-pin coordination

### 3. SPI and I2C Example (`nx_spi_i2c_example.c`)

Demonstrates SPI and I2C interface usage including:

**SPI:**
- Full-duplex transfer (simultaneous TX/RX)
- Transmit-only and receive-only operations
- Bus locking for multi-device access
- Runtime configuration (clock speed, mode)
- Chip select control

**I2C:**
- Master transmit/receive operations
- Memory read/write (EEPROM-style access)
- Device probing and bus scanning
- Runtime speed configuration
- Statistics and error reporting

**Key Features Demonstrated:**
- Bus arbitration and locking
- Memory-mapped device access
- Device discovery and enumeration
- Configuration management
- Error handling

## Building the Examples

The examples are standalone demonstration code. To build them:

```bash
# Using CMake (if integrated into build system)
cmake --build build --target examples

# Or compile individually
gcc -I hal/include -o uart_example docs/examples/nx_uart_example.c -L build/hal -lnx_hal
```

## Running the Examples

```bash
# Run UART example
./uart_example

# Run GPIO example
./gpio_example

# Run SPI/I2C example
./spi_i2c_example
```

## Platform Support

These examples are designed to work with:
- **Native Platform**: Simulation environment for testing
- **STM32F4 Platform**: Real hardware implementation

The examples use the factory pattern, so the same code works across platforms by linking with the appropriate platform library.

## Code Structure

Each example follows this pattern:

1. **Initialization**: Get device via factory and initialize
2. **Configuration**: Set up device parameters
3. **Operation**: Perform device-specific operations
4. **Cleanup**: Deinitialize and release device

## Error Handling

All examples demonstrate proper error handling:
- Check return status codes
- Use `nx_status_to_string()` for error messages
- Clean up resources on error paths
- Verify device state before operations

## Best Practices Demonstrated

1. **Resource Management**: Always release devices after use
2. **Error Checking**: Check all return values
3. **Lifecycle Management**: Proper init/deinit sequences
4. **Configuration Validation**: Verify configuration after changes
5. **Statistics Monitoring**: Use diagnostic interfaces for debugging

## Additional Resources

- **API Documentation**: See `docs/api/html/index.html` (generated by Doxygen)
- **Requirements**: See `.kiro/specs/nexus-hal-refactor/requirements.md`
- **Design Document**: See `.kiro/specs/nexus-hal-refactor/design.md`
- **Test Suite**: See `tests/hal/` for comprehensive test examples

## Notes

- Examples use simplified delay loops for demonstration
- In production code, use proper RTOS delays or timer-based delays
- Platform-specific features may require additional configuration
- Refer to platform documentation for hardware-specific details

## Contributing

When adding new examples:
1. Follow the existing code structure
2. Include comprehensive comments
3. Demonstrate error handling
4. Show both basic and advanced usage
5. Test on multiple platforms if possible
