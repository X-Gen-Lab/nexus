# Chinese (Simplified) translations for Nexus.
# Copyright (C) 2026 Nexus Team
# This file is distributed under the same license as the Nexus project.
#
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2026-01-25 10:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.16.0\n"

#: ../../tutorials/task_creation.rst:2 028813efd5cf4cff834f937bb4cb715b
msgid "Multi-Tasking with OSAL"
msgstr "使用 OSAL 的多任务"

#: ../../tutorials/task_creation.rst:4 ad276114c48f465c9698ea699aa5897e
msgid ""
"This tutorial teaches you how to create multi-tasking applications using the"
" Nexus OSAL (OS Abstraction Layer). You'll learn how to create tasks, use "
"synchronization primitives, and build concurrent applications."
msgstr ""
"This tutorial teaches you how to create multi-tasking applications using the"
" Nexus OSAL (OS Abstraction Layer). You'll learn how to create tasks, use "
"synchronization primitives, and build concurrent applications."

#: ../../tutorials/task_creation.rst:7 3f743ca40b504efe8f5e9a4aaca19251
msgid "Learning Objectives"
msgstr "学习目标"

#: ../../tutorials/task_creation.rst:9 5461de22da0641f1bd15aaff6467dba6
msgid "By the end of this tutorial, you will:"
msgstr "完成本教程后，您将能够："

#: ../../tutorials/task_creation.rst:11 d98f70acf3774d8a9a0cf7dacad0f86e
msgid "Understand RTOS concepts and task scheduling"
msgstr ""

#: ../../tutorials/task_creation.rst:12 4c08ccaa52d54f12b6db66b1216b17b6
msgid "Create and manage multiple tasks"
msgstr ""

#: ../../tutorials/task_creation.rst:13 23b428750c4743be9801066f3eea132d
msgid "Use mutexes for resource protection"
msgstr ""

#: ../../tutorials/task_creation.rst:14 530bd82df1d549c183dc75c291dd4e2f
msgid "Use semaphores for task synchronization"
msgstr ""

#: ../../tutorials/task_creation.rst:15 836a7dab3844416299cb0b674130188b
msgid "Use message queues for inter-task communication"
msgstr ""

#: ../../tutorials/task_creation.rst:16 b3894ee527ba4d94a7c0de8f1e57b017
msgid "Implement producer-consumer patterns"
msgstr ""

#: ../../tutorials/task_creation.rst:19 485322775fff468fab5de32a9d976dd6
msgid "Prerequisites"
msgstr "前置条件"

#: ../../tutorials/task_creation.rst:21 7ece9e622b924e1eb9295b7d7bea3ab2
msgid ""
"Completed :doc:`first_application`, :doc:`gpio_control`, and "
":doc:`uart_communication` tutorials"
msgstr ""

#: ../../tutorials/task_creation.rst:22 bf9dc39418d14895978df94e7c29ebaa
msgid "STM32F4 Discovery board with FreeRTOS support"
msgstr "支持 FreeRTOS 的 STM32F4 Discovery 板"

#: ../../tutorials/task_creation.rst:23 7e6c521fa3644d9698d73691d6645931
msgid "Understanding of concurrent programming concepts"
msgstr ""

#: ../../tutorials/task_creation.rst:26 f065f9a9296643eabc3c43b196f32adc
msgid "OSAL Overview"
msgstr "OSAL 概述"

#: ../../tutorials/task_creation.rst:28 1fe32020da1b441aa11cca5de057e362
msgid "The Nexus OSAL provides a portable interface to RTOS features:"
msgstr ""

#: ../../tutorials/task_creation.rst:30 d50a6d9a3ab4457eaa8ea73d0e4d45b4
msgid "**Tasks**: Independent threads of execution"
msgstr ""

#: ../../tutorials/task_creation.rst:31 ecc6a3af9ae943c0ab7f15705c3c5760
msgid "**Mutexes**: Mutual exclusion for protecting shared resources"
msgstr ""

#: ../../tutorials/task_creation.rst:32 a9f00934cf85425591983850e0b964c1
msgid "**Semaphores**: Signaling between tasks"
msgstr ""

#: ../../tutorials/task_creation.rst:33 29987675bcf54bf087ff6830c2e3c2f0
msgid "**Queues**: Message passing between tasks"
msgstr ""

#: ../../tutorials/task_creation.rst:34 fd6c5b5cf9cf414d8ba76965b8e639ac
msgid "**Timers**: Software timers for periodic operations"
msgstr ""

#: ../../tutorials/task_creation.rst:36 bf9feb829940431ea3e3f1f3f4fb681a
msgid ""
"The OSAL abstracts the underlying RTOS (FreeRTOS, RT-Thread, etc.), allowing"
" your code to be portable."
msgstr ""
"The OSAL abstracts the underlying RTOS (FreeRTOS, RT-Thread, etc.), allowing"
" your code to be portable."

#: ../../tutorials/task_creation.rst:39 266da21ab6924e40acee5d2afc4d50ad
msgid "Part 1: Creating Your First Task"
msgstr ""

#: ../../tutorials/task_creation.rst:42 331d4e7ac7eb416f873e7dc19bbe587f
#, fuzzy
msgid "Task Creation Workflow"
msgstr "Basic 任务 Creation"

#: ../../tutorials/task_creation.rst:44 fd99d495aba94b66810aaee07b080eb2
msgid ""
"The following diagram shows the workflow for creating and managing tasks:"
msgstr ""

#: ../../tutorials/task_creation.rst:78 f9de21b04ec1452f9f86d0e70c640b70
msgid "Basic Task Creation"
msgstr "Basic 任务 Creation"

#: ../../tutorials/task_creation.rst:80 071d819ae9b1471682050138c340553a
msgid ""
"#include \"hal/hal.h\"\n"
"#include \"osal/osal.h\"\n"
"\n"
"/**\n"
" * \\brief           LED blink task\n"
" * \\param[in]       arg: Task argument (unused)\n"
" */\n"
"static void led_task(void* arg) {\n"
"    (void)arg;  /* Unused */\n"
"\n"
"    while (1) {\n"
"        /* Toggle LED */\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 12);\n"
"\n"
"        /* Delay 500ms */\n"
"        osal_task_delay(500);\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    /* Initialize HAL */\n"
"    hal_init();\n"
"\n"
"    /* Initialize LED */\n"
"    hal_gpio_config_t led_config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &led_config);\n"
"\n"
"    /* Initialize OSAL */\n"
"    if (osal_init() != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Create task */\n"
"    osal_task_config_t task_config = {\n"
"        .name = \"LED\",\n"
"        .func = led_task,\n"
"        .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL,\n"
"        .stack_size = 512\n"
"    };\n"
"\n"
"    osal_task_handle_t task_handle;\n"
"    if (osal_task_create(&task_config, &task_handle) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Start OSAL scheduler - this function does not return */\n"
"    osal_start();\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"#include \"hal/hal.h\"\n"
"#include \"osal/osal.h\"\n"
"\n"
"/**\n"
" * \\brief           LED blink task\n"
" * \\param[in]       arg: Task argument (unused)\n"
" */\n"
"static void led_task(void* arg) {\n"
"    (void)arg;  /* Unused */\n"
"\n"
"    while (1) {\n"
"        /* Toggle LED */\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 12);\n"
"\n"
"        /* Delay 500ms */\n"
"        osal_task_delay(500);\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    /* Initialize HAL */\n"
"    hal_init();\n"
"\n"
"    /* Initialize LED */\n"
"    hal_gpio_config_t led_config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &led_config);\n"
"\n"
"    /* Initialize OSAL */\n"
"    if (osal_init() != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Create task */\n"
"    osal_task_config_t task_config = {\n"
"        .name = \"LED\",\n"
"        .func = led_task,\n"
"        .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL,\n"
"        .stack_size = 512\n"
"    };\n"
"\n"
"    osal_task_handle_t task_handle;\n"
"    if (osal_task_create(&task_config, &task_handle) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Start OSAL scheduler - this function does not return */\n"
"    osal_start();\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/task_creation.rst:140 ../../tutorials/task_creation.rst:337
#: 560cc41d75984eafa845183cdace7e27
msgid "**Key Points:**"
msgstr "**Key Points:**"

#: ../../tutorials/task_creation.rst:142 13f9c5b586564fe0a23c8580e703f839
msgid "``osal_init()`` initializes the OSAL subsystem"
msgstr "``osal_init()`` initializes the OSAL subsystem"

#: ../../tutorials/task_creation.rst:143 7a14893684c34312a009285f499ca78b
msgid "``osal_task_create()`` creates a new task"
msgstr "``osal_task_create()`` creates a new task"

#: ../../tutorials/task_creation.rst:144 33a6bdfcd5234b38a07b22384833e58b
msgid "``osal_start()`` starts the scheduler (never returns)"
msgstr "``osal_start()`` starts the scheduler (never returns)"

#: ../../tutorials/task_creation.rst:145 335f12755a0c4392a947bada13bab3df
msgid "``osal_task_delay()`` suspends the task for a specified time"
msgstr "``osal_task_delay()`` suspends the task for a specified time"

#: ../../tutorials/task_creation.rst:148 ba41bcbf45694c81b16316ded0df37a3
msgid "Task Priorities"
msgstr "任务 Priorities"

#: ../../tutorials/task_creation.rst:150 b841c0c780bf428bbf688fc447d69d3a
msgid "OSAL supports multiple priority levels:"
msgstr ""

#: ../../tutorials/task_creation.rst:152 becabcc1f81b4a83b19ca97a63674874
msgid "``OSAL_TASK_PRIORITY_IDLE``: Lowest priority (background tasks)"
msgstr "``OSAL_TASK_PRIORITY_IDLE``: Lowest priority (background tasks)"

#: ../../tutorials/task_creation.rst:153 9c3ac7ca75b54cafa1e4048c70a7a913
msgid "``OSAL_TASK_PRIORITY_LOW``: Low priority"
msgstr ""

#: ../../tutorials/task_creation.rst:154 e779b46ce5f246bd8b9ba2c46da71d5d
msgid "``OSAL_TASK_PRIORITY_NORMAL``: Normal priority (default)"
msgstr "``OSAL_TASK_PRIORITY_NORMAL``: Normal priority (default)"

#: ../../tutorials/task_creation.rst:155 5cc890883b4c4d84aaf890a50f4b9bfe
msgid "``OSAL_TASK_PRIORITY_HIGH``: High priority"
msgstr ""

#: ../../tutorials/task_creation.rst:156 52aadcd4568642b7b13e217bf25f204f
msgid ""
"``OSAL_TASK_PRIORITY_REALTIME``: Highest priority (time-critical tasks)"
msgstr ""
"``OSAL_TASK_PRIORITY_REALTIME``: Highest priority (time-critical tasks)"

#: ../../tutorials/task_creation.rst:158 0c62efec37154ee386f8667ae770a8f0
msgid "Higher priority tasks preempt lower priority tasks."
msgstr ""

#: ../../tutorials/task_creation.rst:161 10c0121ea37b4d2d934985f802a6fb4f
msgid "Part 2: Multiple Tasks"
msgstr ""

#: ../../tutorials/task_creation.rst:164 26f6f3269e8c4aa282c0de87e9a8f27f
msgid "Creating Multiple Tasks"
msgstr ""

#: ../../tutorials/task_creation.rst:166 3055a3ed6c464f12b1ed540efe9f1713
msgid ""
"#define TASK_STACK_SIZE  1024\n"
"\n"
"/**\n"
" * \\brief           Green LED task\n"
" */\n"
"static void green_led_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 12);  /* Green */\n"
"        osal_task_delay(500);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Orange LED task\n"
" */\n"
"static void orange_led_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 13);  /* Orange */\n"
"        osal_task_delay(300);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Red LED task\n"
" */\n"
"static void red_led_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 14);  /* Red */\n"
"        osal_task_delay(700);\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize all LEDs */\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 13, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 14, &config);\n"
"\n"
"    /* Initialize OSAL */\n"
"    osal_init();\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t task_configs[] = {\n"
"        {.name = \"Green\", .func = green_led_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Orange\", .func = orange_led_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Red\", .func = red_led_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = TASK_STACK_SIZE}\n"
"    };\n"
"\n"
"    for (size_t i = 0; i < 3; i++) {\n"
"        osal_task_handle_t handle;\n"
"        osal_task_create(&task_configs[i], &handle);\n"
"    }\n"
"\n"
"    /* Start scheduler */\n"
"    osal_start();\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"#define TASK_STACK_SIZE  1024\n"
"\n"
"/**\n"
" * \\brief           Green LED task\n"
" */\n"
"static void green_led_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 12);  /* Green */\n"
"        osal_task_delay(500);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Orange LED task\n"
" */\n"
"static void orange_led_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 13);  /* Orange */\n"
"        osal_task_delay(300);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Red LED task\n"
" */\n"
"static void red_led_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 14);  /* Red */\n"
"        osal_task_delay(700);\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize all LEDs */\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 13, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 14, &config);\n"
"\n"
"    /* Initialize OSAL */\n"
"    osal_init();\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t task_configs[] = {\n"
"        {.name = \"Green\", .func = green_led_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Orange\", .func = orange_led_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Red\", .func = red_led_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = TASK_STACK_SIZE}\n"
"    };\n"
"\n"
"    for (size_t i = 0; i < 3; i++) {\n"
"        osal_task_handle_t handle;\n"
"        osal_task_create(&task_configs[i], &handle);\n"
"    }\n"
"\n"
"    /* Start scheduler */\n"
"    osal_start();\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/task_creation.rst:245 e6a408a05d424574a0b2be0dd94e9ce2
msgid "**Result**: All three LEDs blink independently at different rates."
msgstr ""

#: ../../tutorials/task_creation.rst:248 5572cb20d43b4463b5a0f2c2ed122d22
msgid "Part 3: Mutexes for Resource Protection"
msgstr ""

#: ../../tutorials/task_creation.rst:251 fa28b49f6014432080d9f76bf5613586
msgid "The Problem: Shared Resources"
msgstr ""

#: ../../tutorials/task_creation.rst:253 f453f7b7f9fa4cd29f5b129f61b8b9b9
msgid ""
"When multiple tasks access shared resources, race conditions can occur:"
msgstr ""

#: ../../tutorials/task_creation.rst:255 433e8868b88440ad938028188b38cf6f
msgid ""
"/* WRONG: No protection */\n"
"static uint32_t shared_counter = 0;\n"
"\n"
"static void task1(void* arg) {\n"
"    while (1) {\n"
"        shared_counter++;  /* Race condition! */\n"
"        osal_task_delay(10);\n"
"    }\n"
"}\n"
"\n"
"static void task2(void* arg) {\n"
"    while (1) {\n"
"        shared_counter++;  /* Race condition! */\n"
"        osal_task_delay(10);\n"
"    }\n"
"}"
msgstr ""
"/* WRONG: No protection */\n"
"static uint32_t shared_counter = 0;\n"
"\n"
"static void task1(void* arg) {\n"
"    while (1) {\n"
"        shared_counter++;  /* Race condition! */\n"
"        osal_task_delay(10);\n"
"    }\n"
"}\n"
"\n"
"static void task2(void* arg) {\n"
"    while (1) {\n"
"        shared_counter++;  /* Race condition! */\n"
"        osal_task_delay(10);\n"
"    }\n"
"}"

#: ../../tutorials/task_creation.rst:275 2a69340efec94565a7834aca65fbceb2
msgid "The Solution: Mutexes"
msgstr ""

#: ../../tutorials/task_creation.rst:277 8cda1089f8c34ded9d4478293e02f556
msgid ""
"static uint32_t shared_counter = 0;\n"
"static osal_mutex_handle_t counter_mutex;\n"
"\n"
"/**\n"
" * \\brief           Increment counter safely\n"
" */\n"
"static void increment_counter(void) {\n"
"    /* Lock mutex */\n"
"    if (osal_mutex_lock(counter_mutex, 1000) == OSAL_OK) {\n"
"        /* Critical section - only one task can be here */\n"
"        shared_counter++;\n"
"\n"
"        /* Unlock mutex */\n"
"        osal_mutex_unlock(counter_mutex);\n"
"    }\n"
"}\n"
"\n"
"static void task1(void* arg) {\n"
"    while (1) {\n"
"        increment_counter();\n"
"        osal_task_delay(10);\n"
"    }\n"
"}\n"
"\n"
"static void task2(void* arg) {\n"
"    while (1) {\n"
"        increment_counter();\n"
"        osal_task_delay(10);\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"    osal_init();\n"
"\n"
"    /* Create mutex */\n"
"    if (osal_mutex_create(&counter_mutex) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t config1 = {\n"
"        .name = \"Task1\", .func = task1, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = 1024\n"
"    };\n"
"    osal_task_config_t config2 = {\n"
"        .name = \"Task2\", .func = task2, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = 1024\n"
"    };\n"
"\n"
"    osal_task_handle_t h1, h2;\n"
"    osal_task_create(&config1, &h1);\n"
"    osal_task_create(&config2, &h2);\n"
"\n"
"    osal_start();\n"
"    return 0;\n"
"}"
msgstr ""
"static uint32_t shared_counter = 0;\n"
"static osal_mutex_handle_t counter_mutex;\n"
"\n"
"/**\n"
" * \\brief           Increment counter safely\n"
" */\n"
"static void increment_counter(void) {\n"
"    /* Lock mutex */\n"
"    if (osal_mutex_lock(counter_mutex, 1000) == OSAL_OK) {\n"
"        /* Critical section - only one task can be here */\n"
"        shared_counter++;\n"
"\n"
"        /* Unlock mutex */\n"
"        osal_mutex_unlock(counter_mutex);\n"
"    }\n"
"}\n"
"\n"
"static void task1(void* arg) {\n"
"    while (1) {\n"
"        increment_counter();\n"
"        osal_task_delay(10);\n"
"    }\n"
"}\n"
"\n"
"static void task2(void* arg) {\n"
"    while (1) {\n"
"        increment_counter();\n"
"        osal_task_delay(10);\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"    osal_init();\n"
"\n"
"    /* Create mutex */\n"
"    if (osal_mutex_create(&counter_mutex) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t config1 = {\n"
"        .name = \"Task1\", .func = task1, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = 1024\n"
"    };\n"
"    osal_task_config_t config2 = {\n"
"        .name = \"Task2\", .func = task2, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = 1024\n"
"    };\n"
"\n"
"    osal_task_handle_t h1, h2;\n"
"    osal_task_create(&config1, &h1);\n"
"    osal_task_create(&config2, &h2);\n"
"\n"
"    osal_start();\n"
"    return 0;\n"
"}"

#: ../../tutorials/task_creation.rst:339 55f396282e2f48d1b24394bcbc4c0249
msgid "Always lock mutex before accessing shared resource"
msgstr ""

#: ../../tutorials/task_creation.rst:340 b773676fc843441ca077ab7339076865
msgid "Always unlock mutex after accessing shared resource"
msgstr ""

#: ../../tutorials/task_creation.rst:341 343163a4101b4836a6b3f578632b8daf
msgid "Use timeout to avoid deadlocks"
msgstr ""

#: ../../tutorials/task_creation.rst:342 3af52bc8110e46ea880795e4ac5ea7bc
msgid "Keep critical sections short"
msgstr ""

#: ../../tutorials/task_creation.rst:345 9e03d988f5314703b7cfa2ef3fdac1f3
msgid "Part 4: Semaphores for Synchronization"
msgstr ""

#: ../../tutorials/task_creation.rst:348 89e3e04000c04244bb043208e27aa716
msgid "Binary Semaphores"
msgstr ""

#: ../../tutorials/task_creation.rst:350 00e0e0b0e4f04ee1b0bc845ef98ed78f
msgid "Use binary semaphores for signaling between tasks:"
msgstr ""

#: ../../tutorials/task_creation.rst:352 f8ef210f8d964b22aca264c864361ab6
msgid ""
"static osal_sem_handle_t button_sem;\n"
"\n"
"/**\n"
" * \\brief           Button monitoring task\n"
" */\n"
"static void button_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        /* Check button state */\n"
"        if (hal_gpio_read(HAL_GPIO_PORT_A, 0) == HAL_GPIO_LEVEL_HIGH) {\n"
"            /* Button pressed - signal LED task */\n"
"            osal_sem_give(button_sem);\n"
"\n"
"            /* Wait for button release */\n"
"            while (hal_gpio_read(HAL_GPIO_PORT_A, 0) == HAL_GPIO_LEVEL_HIGH) {\n"
"                osal_task_delay(10);\n"
"            }\n"
"        }\n"
"\n"
"        osal_task_delay(10);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           LED control task\n"
" */\n"
"static void led_control_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        /* Wait for button press signal */\n"
"        if (osal_sem_take(button_sem, OSAL_WAIT_FOREVER) == OSAL_OK) {\n"
"            /* Toggle LED */\n"
"            hal_gpio_toggle(HAL_GPIO_PORT_D, 12);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize button and LED */\n"
"    hal_gpio_config_t btn_config = {\n"
"        .direction = HAL_GPIO_DIR_INPUT,\n"
"        .pull = HAL_GPIO_PULL_DOWN,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_A, 0, &btn_config);\n"
"\n"
"    hal_gpio_config_t led_config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &led_config);\n"
"\n"
"    osal_init();\n"
"\n"
"    /* Create binary semaphore */\n"
"    if (osal_sem_create_binary(&button_sem) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t btn_task_config = {\n"
"        .name = \"Button\", .func = button_task, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_HIGH, .stack_size = 1024\n"
"    };\n"
"    osal_task_config_t led_task_config = {\n"
"        .name = \"LED\", .func = led_control_task, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = 1024\n"
"    };\n"
"\n"
"    osal_task_handle_t h1, h2;\n"
"    osal_task_create(&btn_task_config, &h1);\n"
"    osal_task_create(&led_task_config, &h2);\n"
"\n"
"    osal_start();\n"
"    return 0;\n"
"}"
msgstr ""
"static osal_sem_handle_t button_sem;\n"
"\n"
"/**\n"
" * \\brief           Button monitoring task\n"
" */\n"
"static void button_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        /* Check button state */\n"
"        if (hal_gpio_read(HAL_GPIO_PORT_A, 0) == HAL_GPIO_LEVEL_HIGH) {\n"
"            /* Button pressed - signal LED task */\n"
"            osal_sem_give(button_sem);\n"
"\n"
"            /* Wait for button release */\n"
"            while (hal_gpio_read(HAL_GPIO_PORT_A, 0) == HAL_GPIO_LEVEL_HIGH) {\n"
"                osal_task_delay(10);\n"
"            }\n"
"        }\n"
"\n"
"        osal_task_delay(10);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           LED control task\n"
" */\n"
"static void led_control_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        /* Wait for button press signal */\n"
"        if (osal_sem_take(button_sem, OSAL_WAIT_FOREVER) == OSAL_OK) {\n"
"            /* Toggle LED */\n"
"            hal_gpio_toggle(HAL_GPIO_PORT_D, 12);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize button and LED */\n"
"    hal_gpio_config_t btn_config = {\n"
"        .direction = HAL_GPIO_DIR_INPUT,\n"
"        .pull = HAL_GPIO_PULL_DOWN,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_A, 0, &btn_config);\n"
"\n"
"    hal_gpio_config_t led_config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &led_config);\n"
"\n"
"    osal_init();\n"
"\n"
"    /* Create binary semaphore */\n"
"    if (osal_sem_create_binary(&button_sem) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t btn_task_config = {\n"
"        .name = \"Button\", .func = button_task, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_HIGH, .stack_size = 1024\n"
"    };\n"
"    osal_task_config_t led_task_config = {\n"
"        .name = \"LED\", .func = led_control_task, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = 1024\n"
"    };\n"
"\n"
"    osal_task_handle_t h1, h2;\n"
"    osal_task_create(&btn_task_config, &h1);\n"
"    osal_task_create(&led_task_config, &h2);\n"
"\n"
"    osal_start();\n"
"    return 0;\n"
"}"

#: ../../tutorials/task_creation.rst:441 4d4fed62cd4d4a10a89c0aba1708efc0
msgid "Counting Semaphores"
msgstr ""

#: ../../tutorials/task_creation.rst:443 5c4ad077c7784a3fb2fb31f51d42ce30
msgid "Use counting semaphores to track resource availability:"
msgstr ""

#: ../../tutorials/task_creation.rst:445 82a8128393524958b7f21ea7f234f960
msgid ""
"#define MAX_RESOURCES  5\n"
"\n"
"static osal_sem_handle_t resource_sem;\n"
"\n"
"/**\n"
" * \\brief           Acquire resource\n"
" * \\return          true if acquired, false if timeout\n"
" */\n"
"static bool acquire_resource(uint32_t timeout_ms) {\n"
"    return (osal_sem_take(resource_sem, timeout_ms) == OSAL_OK);\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Release resource\n"
" */\n"
"static void release_resource(void) {\n"
"    osal_sem_give(resource_sem);\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"    osal_init();\n"
"\n"
"    /* Create counting semaphore with 5 resources */\n"
"    if (osal_sem_create_counting(MAX_RESOURCES, MAX_RESOURCES, &resource_sem) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Tasks can now acquire/release resources */\n"
"    /* ... */\n"
"\n"
"    osal_start();\n"
"    return 0;\n"
"}"
msgstr ""
"#define MAX_RESOURCES  5\n"
"\n"
"static osal_sem_handle_t resource_sem;\n"
"\n"
"/**\n"
" * \\brief           Acquire resource\n"
" * \\return          true if acquired, false if timeout\n"
" */\n"
"static bool acquire_resource(uint32_t timeout_ms) {\n"
"    return (osal_sem_take(resource_sem, timeout_ms) == OSAL_OK);\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Release resource\n"
" */\n"
"static void release_resource(void) {\n"
"    osal_sem_give(resource_sem);\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"    osal_init();\n"
"\n"
"    /* Create counting semaphore with 5 resources */\n"
"    if (osal_sem_create_counting(MAX_RESOURCES, MAX_RESOURCES, &resource_sem) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Tasks can now acquire/release resources */\n"
"    /* ... */\n"
"\n"
"    osal_start();\n"
"    return 0;\n"
"}"

#: ../../tutorials/task_creation.rst:483 56f3d25fb12b4a46a22b2ebe537ef035
msgid "Part 5: Message Queues"
msgstr ""

#: ../../tutorials/task_creation.rst:486 7c6df590724d49fab063b611bce34d01
msgid "Producer-Consumer Pattern"
msgstr "生产者-消费者模式"

#: ../../tutorials/task_creation.rst:488 45c958af308b4ad5b1fd82d0b4bbf935
msgid ""
"/**\n"
" * \\brief           Sensor data structure\n"
" */\n"
"typedef struct {\n"
"    uint32_t timestamp;\n"
"    int32_t temperature;\n"
"    int32_t humidity;\n"
"} sensor_data_t;\n"
"\n"
"#define QUEUE_SIZE  10\n"
"\n"
"static osal_queue_handle_t sensor_queue;\n"
"\n"
"/**\n"
" * \\brief           Producer task - reads sensors\n"
" */\n"
"static void producer_task(void* arg) {\n"
"    (void)arg;\n"
"    uint32_t sample_count = 0;\n"
"\n"
"    while (1) {\n"
"        /* Read sensor data (simulated) */\n"
"        sensor_data_t data = {\n"
"            .timestamp = hal_get_tick(),\n"
"            .temperature = 25 + (sample_count % 10),\n"
"            .humidity = 60 + (sample_count % 20)\n"
"        };\n"
"\n"
"        /* Send to queue */\n"
"        if (osal_queue_send(sensor_queue, &data, 100) == OSAL_OK) {\n"
"            /* Success */\n"
"            sample_count++;\n"
"        } else {\n"
"            /* Queue full */\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 14, HAL_GPIO_LEVEL_HIGH);  /* Red LED */\n"
"        }\n"
"\n"
"        /* Sample every 1 second */\n"
"        osal_task_delay(1000);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Consumer task - processes data\n"
" */\n"
"static void consumer_task(void* arg) {\n"
"    (void)arg;\n"
"    sensor_data_t data;\n"
"\n"
"    while (1) {\n"
"        /* Receive from queue */\n"
"        if (osal_queue_receive(sensor_queue, &data, OSAL_WAIT_FOREVER) == OSAL_OK) {\n"
"            /* Process data */\n"
"            /* In real application, would log or transmit data */\n"
"\n"
"            /* Toggle LED to show activity */\n"
"            hal_gpio_toggle(HAL_GPIO_PORT_D, 12);  /* Green LED */\n"
"\n"
"            /* Clear error LED */\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 14, HAL_GPIO_LEVEL_LOW);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize LEDs */\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 14, &config);\n"
"\n"
"    osal_init();\n"
"\n"
"    /* Create queue */\n"
"    if (osal_queue_create(sizeof(sensor_data_t), QUEUE_SIZE, &sensor_queue) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t producer_config = {\n"
"        .name = \"Producer\", .func = producer_task, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = 1024\n"
"    };\n"
"    osal_task_config_t consumer_config = {\n"
"        .name = \"Consumer\", .func = consumer_task, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_HIGH, .stack_size = 1024\n"
"    };\n"
"\n"
"    osal_task_handle_t h1, h2;\n"
"    osal_task_create(&producer_config, &h1);\n"
"    osal_task_create(&consumer_config, &h2);\n"
"\n"
"    osal_start();\n"
"    return 0;\n"
"}"
msgstr ""
"/**\n"
" * \\brief           Sensor data structure\n"
" */\n"
"typedef struct {\n"
"    uint32_t timestamp;\n"
"    int32_t temperature;\n"
"    int32_t humidity;\n"
"} sensor_data_t;\n"
"\n"
"#define QUEUE_SIZE  10\n"
"\n"
"static osal_queue_handle_t sensor_queue;\n"
"\n"
"/**\n"
" * \\brief           Producer task - reads sensors\n"
" */\n"
"static void producer_task(void* arg) {\n"
"    (void)arg;\n"
"    uint32_t sample_count = 0;\n"
"\n"
"    while (1) {\n"
"        /* Read sensor data (simulated) */\n"
"        sensor_data_t data = {\n"
"            .timestamp = hal_get_tick(),\n"
"            .temperature = 25 + (sample_count % 10),\n"
"            .humidity = 60 + (sample_count % 20)\n"
"        };\n"
"\n"
"        /* Send to queue */\n"
"        if (osal_queue_send(sensor_queue, &data, 100) == OSAL_OK) {\n"
"            /* Success */\n"
"            sample_count++;\n"
"        } else {\n"
"            /* Queue full */\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 14, HAL_GPIO_LEVEL_HIGH);  /* Red LED */\n"
"        }\n"
"\n"
"        /* Sample every 1 second */\n"
"        osal_task_delay(1000);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Consumer task - processes data\n"
" */\n"
"static void consumer_task(void* arg) {\n"
"    (void)arg;\n"
"    sensor_data_t data;\n"
"\n"
"    while (1) {\n"
"        /* Receive from queue */\n"
"        if (osal_queue_receive(sensor_queue, &data, OSAL_WAIT_FOREVER) == OSAL_OK) {\n"
"            /* Process data */\n"
"            /* In real application, would log or transmit data */\n"
"\n"
"            /* Toggle LED to show activity */\n"
"            hal_gpio_toggle(HAL_GPIO_PORT_D, 12);  /* Green LED */\n"
"\n"
"            /* Clear error LED */\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 14, HAL_GPIO_LEVEL_LOW);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize LEDs */\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 14, &config);\n"
"\n"
"    osal_init();\n"
"\n"
"    /* Create queue */\n"
"    if (osal_queue_create(sizeof(sensor_data_t), QUEUE_SIZE, &sensor_queue) != OSAL_OK) {\n"
"        while (1) { /* Error */ }\n"
"    }\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t producer_config = {\n"
"        .name = \"Producer\", .func = producer_task, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = 1024\n"
"    };\n"
"    osal_task_config_t consumer_config = {\n"
"        .name = \"Consumer\", .func = consumer_task, .arg = NULL,\n"
"        .priority = OSAL_TASK_PRIORITY_HIGH, .stack_size = 1024\n"
"    };\n"
"\n"
"    osal_task_handle_t h1, h2;\n"
"    osal_task_create(&producer_config, &h1);\n"
"    osal_task_create(&consumer_config, &h2);\n"
"\n"
"    osal_start();\n"
"    return 0;\n"
"}"

#: ../../tutorials/task_creation.rst:594 d202156f3f1f4820a7fa36870ee098b3
msgid "Part 6: Complete Example"
msgstr ""

#: ../../tutorials/task_creation.rst:596 6c64748057b44fa0859a941e2d46661a
msgid "Here's a complete multi-tasking application:"
msgstr ""

#: ../../tutorials/task_creation.rst:598 2eae6449480a4edd92d1265c0f7f5b02
msgid ""
"/**\n"
" * \\file            multitask_demo.c\n"
" * \\brief           Complete OSAL Multi-Tasking Demo\n"
" */\n"
"\n"
"#include \"hal/hal.h\"\n"
"#include \"osal/osal.h\"\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Configuration                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"#define TASK_STACK_SIZE     1024\n"
"#define SENSOR_QUEUE_SIZE   10\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Data Structures                                                       */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"typedef struct {\n"
"    uint32_t timestamp;\n"
"    uint32_t sensor_id;\n"
"    int32_t value;\n"
"} sensor_msg_t;\n"
"\n"
"typedef struct {\n"
"    uint32_t samples_produced;\n"
"    uint32_t samples_consumed;\n"
"    uint32_t queue_overflows;\n"
"} stats_t;\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Global Variables                                                      */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static osal_queue_handle_t g_sensor_queue;\n"
"static osal_mutex_handle_t g_stats_mutex;\n"
"static osal_sem_handle_t g_data_ready_sem;\n"
"static stats_t g_stats = {0};\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Helper Functions                                                      */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static void update_stats(int produced, int consumed, int overflow) {\n"
"    if (osal_mutex_lock(g_stats_mutex, 100) == OSAL_OK) {\n"
"        g_stats.samples_produced += produced;\n"
"        g_stats.samples_consumed += consumed;\n"
"        g_stats.queue_overflows += overflow;\n"
"        osal_mutex_unlock(g_stats_mutex);\n"
"    }\n"
"}\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Tasks                                                                 */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static void producer_task(void* arg) {\n"
"    (void)arg;\n"
"    uint32_t sensor_id = 0;\n"
"\n"
"    while (1) {\n"
"        sensor_msg_t msg = {\n"
"            .timestamp = hal_get_tick(),\n"
"            .sensor_id = sensor_id,\n"
"            .value = (int32_t)(hal_get_tick() % 1000)\n"
"        };\n"
"\n"
"        if (osal_queue_send(g_sensor_queue, &msg, 10) == OSAL_OK) {\n"
"            osal_sem_give(g_data_ready_sem);\n"
"            update_stats(1, 0, 0);\n"
"        } else {\n"
"            update_stats(0, 0, 1);\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 14, HAL_GPIO_LEVEL_HIGH);\n"
"        }\n"
"\n"
"        sensor_id = (sensor_id + 1) % 4;\n"
"        osal_task_delay(100);\n"
"    }\n"
"}\n"
"\n"
"static void consumer_task(void* arg) {\n"
"    (void)arg;\n"
"    sensor_msg_t msg;\n"
"\n"
"    while (1) {\n"
"        if (osal_sem_take(g_data_ready_sem, 500) == OSAL_OK) {\n"
"            if (osal_queue_receive(g_sensor_queue, &msg, 10) == OSAL_OK) {\n"
"                update_stats(0, 1, 0);\n"
"                hal_gpio_toggle(HAL_GPIO_PORT_D, 13);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"static void heartbeat_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 12);\n"
"        osal_task_delay(500);\n"
"    }\n"
"}\n"
"\n"
"static void stats_task(void* arg) {\n"
"    (void)arg;\n"
"    stats_t local_stats;\n"
"\n"
"    while (1) {\n"
"        osal_task_delay(2000);\n"
"\n"
"        if (osal_mutex_lock(g_stats_mutex, 100) == OSAL_OK) {\n"
"            local_stats = g_stats;\n"
"            osal_mutex_unlock(g_stats_mutex);\n"
"\n"
"            /* In real app, would print stats via UART */\n"
"            if (local_stats.queue_overflows == 0) {\n"
"                hal_gpio_write(HAL_GPIO_PORT_D, 14, HAL_GPIO_LEVEL_LOW);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Main Function                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize LEDs */\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 13, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 14, &config);\n"
"\n"
"    /* Initialize OSAL */\n"
"    osal_init();\n"
"\n"
"    /* Create synchronization objects */\n"
"    osal_queue_create(sizeof(sensor_msg_t), SENSOR_QUEUE_SIZE, &g_sensor_queue);\n"
"    osal_mutex_create(&g_stats_mutex);\n"
"    osal_sem_create_counting(SENSOR_QUEUE_SIZE, 0, &g_data_ready_sem);\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t tasks[] = {\n"
"        {.name = \"Producer\", .func = producer_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Consumer\", .func = consumer_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_HIGH, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Heartbeat\", .func = heartbeat_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_LOW, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Stats\", .func = stats_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_LOW, .stack_size = TASK_STACK_SIZE}\n"
"    };\n"
"\n"
"    for (size_t i = 0; i < 4; i++) {\n"
"        osal_task_handle_t handle;\n"
"        osal_task_create(&tasks[i], &handle);\n"
"    }\n"
"\n"
"    /* Start scheduler */\n"
"    osal_start();\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"/**\n"
" * \\file            multitask_demo.c\n"
" * \\brief           Complete OSAL Multi-Tasking Demo\n"
" */\n"
"\n"
"#include \"hal/hal.h\"\n"
"#include \"osal/osal.h\"\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Configuration                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"#define TASK_STACK_SIZE     1024\n"
"#define SENSOR_QUEUE_SIZE   10\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Data Structures                                                       */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"typedef struct {\n"
"    uint32_t timestamp;\n"
"    uint32_t sensor_id;\n"
"    int32_t value;\n"
"} sensor_msg_t;\n"
"\n"
"typedef struct {\n"
"    uint32_t samples_produced;\n"
"    uint32_t samples_consumed;\n"
"    uint32_t queue_overflows;\n"
"} stats_t;\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Global Variables                                                      */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static osal_queue_handle_t g_sensor_queue;\n"
"static osal_mutex_handle_t g_stats_mutex;\n"
"static osal_sem_handle_t g_data_ready_sem;\n"
"static stats_t g_stats = {0};\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Helper Functions                                                      */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static void update_stats(int produced, int consumed, int overflow) {\n"
"    if (osal_mutex_lock(g_stats_mutex, 100) == OSAL_OK) {\n"
"        g_stats.samples_produced += produced;\n"
"        g_stats.samples_consumed += consumed;\n"
"        g_stats.queue_overflows += overflow;\n"
"        osal_mutex_unlock(g_stats_mutex);\n"
"    }\n"
"}\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Tasks                                                                 */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static void producer_task(void* arg) {\n"
"    (void)arg;\n"
"    uint32_t sensor_id = 0;\n"
"\n"
"    while (1) {\n"
"        sensor_msg_t msg = {\n"
"            .timestamp = hal_get_tick(),\n"
"            .sensor_id = sensor_id,\n"
"            .value = (int32_t)(hal_get_tick() % 1000)\n"
"        };\n"
"\n"
"        if (osal_queue_send(g_sensor_queue, &msg, 10) == OSAL_OK) {\n"
"            osal_sem_give(g_data_ready_sem);\n"
"            update_stats(1, 0, 0);\n"
"        } else {\n"
"            update_stats(0, 0, 1);\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 14, HAL_GPIO_LEVEL_HIGH);\n"
"        }\n"
"\n"
"        sensor_id = (sensor_id + 1) % 4;\n"
"        osal_task_delay(100);\n"
"    }\n"
"}\n"
"\n"
"static void consumer_task(void* arg) {\n"
"    (void)arg;\n"
"    sensor_msg_t msg;\n"
"\n"
"    while (1) {\n"
"        if (osal_sem_take(g_data_ready_sem, 500) == OSAL_OK) {\n"
"            if (osal_queue_receive(g_sensor_queue, &msg, 10) == OSAL_OK) {\n"
"                update_stats(0, 1, 0);\n"
"                hal_gpio_toggle(HAL_GPIO_PORT_D, 13);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"static void heartbeat_task(void* arg) {\n"
"    (void)arg;\n"
"\n"
"    while (1) {\n"
"        hal_gpio_toggle(HAL_GPIO_PORT_D, 12);\n"
"        osal_task_delay(500);\n"
"    }\n"
"}\n"
"\n"
"static void stats_task(void* arg) {\n"
"    (void)arg;\n"
"    stats_t local_stats;\n"
"\n"
"    while (1) {\n"
"        osal_task_delay(2000);\n"
"\n"
"        if (osal_mutex_lock(g_stats_mutex, 100) == OSAL_OK) {\n"
"            local_stats = g_stats;\n"
"            osal_mutex_unlock(g_stats_mutex);\n"
"\n"
"            /* In real app, would print stats via UART */\n"
"            if (local_stats.queue_overflows == 0) {\n"
"                hal_gpio_write(HAL_GPIO_PORT_D, 14, HAL_GPIO_LEVEL_LOW);\n"
"            }\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Main Function                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize LEDs */\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 13, &config);\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 14, &config);\n"
"\n"
"    /* Initialize OSAL */\n"
"    osal_init();\n"
"\n"
"    /* Create synchronization objects */\n"
"    osal_queue_create(sizeof(sensor_msg_t), SENSOR_QUEUE_SIZE, &g_sensor_queue);\n"
"    osal_mutex_create(&g_stats_mutex);\n"
"    osal_sem_create_counting(SENSOR_QUEUE_SIZE, 0, &g_data_ready_sem);\n"
"\n"
"    /* Create tasks */\n"
"    osal_task_config_t tasks[] = {\n"
"        {.name = \"Producer\", .func = producer_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_NORMAL, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Consumer\", .func = consumer_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_HIGH, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Heartbeat\", .func = heartbeat_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_LOW, .stack_size = TASK_STACK_SIZE},\n"
"        {.name = \"Stats\", .func = stats_task, .arg = NULL,\n"
"         .priority = OSAL_TASK_PRIORITY_LOW, .stack_size = TASK_STACK_SIZE}\n"
"    };\n"
"\n"
"    for (size_t i = 0; i < 4; i++) {\n"
"        osal_task_handle_t handle;\n"
"        osal_task_create(&tasks[i], &handle);\n"
"    }\n"
"\n"
"    /* Start scheduler */\n"
"    osal_start();\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/task_creation.rst:774 73e719e6bbe74c6d9555ad53a326bbae
msgid "Best Practices"
msgstr "最佳实践"

#: ../../tutorials/task_creation.rst:776 49dc0648d77844ba9d0413a98aa619c8
msgid "**Task Design**: Keep tasks focused on a single responsibility"
msgstr ""

#: ../../tutorials/task_creation.rst:778 4b6df6e9bd4a4c78b118b1915e000e3e
msgid ""
"**Stack Size**: Allocate sufficient stack for each task (monitor usage)"
msgstr ""
"**Stack Size**: Allocate sufficient stack for each task (monitor usage)"

#: ../../tutorials/task_creation.rst:780 ef6e30cca2a644fbaff3de17d89eeb65
msgid ""
"**Priority Assignment**: Use appropriate priorities (avoid priority "
"inversion)"
msgstr ""
"**Priority Assignment**: Use appropriate priorities (avoid priority "
"inversion)"

#: ../../tutorials/task_creation.rst:782 927db321e9a94a679170841059959125
msgid "**Synchronization**: Always protect shared resources with mutexes"
msgstr ""

#: ../../tutorials/task_creation.rst:784 64d7c9b458f9429bbee1c9d40b6c19ca
msgid ""
"**Deadlock Prevention**: - Always acquire mutexes in the same order - Use "
"timeouts - Keep critical sections short"
msgstr ""

#: ../../tutorials/task_creation.rst:789 73eff8d330bd455fb333b8e379a51cfe
msgid "**Queue Sizing**: Size queues appropriately for your data rate"
msgstr ""

#: ../../tutorials/task_creation.rst:791 a1ae035bffa646589bb14f701405b359
msgid "**Error Handling**: Always check return values from OSAL functions"
msgstr ""

#: ../../tutorials/task_creation.rst:793 c866cb95639b4759bbe9e0f15a3a4275
msgid ""
"**Task Cleanup**: Tasks should run forever or call ``osal_task_delete()`` "
"before returning"
msgstr ""
"**Task Cleanup**: Tasks should run forever or call ``osal_task_delete()`` "
"before returning"

#: ../../tutorials/task_creation.rst:796 c0325b6f9c494677a5b311fa7249b1a8
msgid "Common Issues"
msgstr "常见问题"

#: ../../tutorials/task_creation.rst:798 8f263d2ae152400ea9050632798ad1d3
msgid "**Stack Overflow:**"
msgstr "**Stack Overflow:**"

#: ../../tutorials/task_creation.rst:800 0a3d649e84b447429bba2d60c2e406c2
msgid ""
"Symptoms: System crashes, hard faults Solution: Increase stack size, reduce "
"local variables, avoid deep recursion"
msgstr ""

#: ../../tutorials/task_creation.rst:803 17f7dae97e184d8ca2e1056352b33248
msgid "**Priority Inversion:**"
msgstr "**Priority Inversion:**"

#: ../../tutorials/task_creation.rst:805 fbb765a30f49431a9b1872bbe5918e3c
msgid ""
"Symptoms: High-priority task blocked by low-priority task Solution: Use "
"priority inheritance mutexes"
msgstr ""

#: ../../tutorials/task_creation.rst:808 7ed6b532a6b04932939af64a7732e659
msgid "**Deadlock:**"
msgstr "**Deadlock:**"

#: ../../tutorials/task_creation.rst:810 6208d91e9e024073a9b59f427e520ca6
msgid ""
"Symptoms: System hangs Solution: Always acquire locks in same order, use "
"timeouts"
msgstr ""

#: ../../tutorials/task_creation.rst:813 54cd0bebc47c4ab68ff8c5be394915a5
msgid "**Queue Overflow:**"
msgstr "**Queue Overflow:**"

#: ../../tutorials/task_creation.rst:815 4711f69824b640658a2302a041c5175c
msgid ""
"Symptoms: Data loss Solution: Increase queue size, process data faster, add "
"flow control"
msgstr ""

#: ../../tutorials/task_creation.rst:819 6a698846630b41dca2517ccc3c2d2eee
msgid "Next Steps"
msgstr "下一步"

#: ../../tutorials/task_creation.rst:821 84896b516da54ac2b7399eb644268839
msgid "Explore the :doc:`../user_guide/osal` for complete OSAL API reference"
msgstr ""

#: ../../tutorials/task_creation.rst:822 108b1201284b420d9887f94a49884be2
msgid ""
"Check out the FreeRTOS demo application in ``applications/freertos_demo/``"
msgstr ""

#: ../../tutorials/task_creation.rst:823 b5d82053407f4b5cab82e980f924e07a
msgid "Learn about :doc:`../user_guide/log` for logging from multiple tasks"
msgstr ""

#: ../../tutorials/task_creation.rst:824 8124327377994e389162afac51f2031c
msgid ""
"Read about :doc:`../platform_guides/stm32f4` for platform-specific details"
msgstr ""
