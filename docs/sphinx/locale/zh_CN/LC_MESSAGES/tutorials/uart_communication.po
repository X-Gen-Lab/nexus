# Chinese (Simplified) translations for Nexus.
# Copyright (C) 2026 Nexus Team
# This file is distributed under the same license as the Nexus project.
#
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2026-01-25 10:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.16.0\n"

#: ../../tutorials/uart_communication.rst:2 215a98f397b140f8889e1fa3f05a08c1
msgid "UART Communication Tutorial"
msgstr "UART Communication 教程"

#: ../../tutorials/uart_communication.rst:4 9ceb3bedbfce477c88bdb7807810afeb
msgid ""
"This tutorial teaches you how to use UART (Universal Asynchronous "
"Receiver/Transmitter) for serial communication with the Nexus HAL. You'll "
"learn how to send and receive data, implement protocols, and debug your "
"applications."
msgstr ""
"This tutorial teaches you how to use UART (Universal Asynchronous "
"Receiver/Transmitter) for serial communication with the Nexus HAL. You'll "
"learn how to send and receive data, implement protocols, and debug your "
"applications."

#: ../../tutorials/uart_communication.rst:7 934ab7b8d433416f8c88a1dd5f6bc9e6
msgid "Learning Objectives"
msgstr "学习目标"

#: ../../tutorials/uart_communication.rst:9 964877c7436a4c0fae85aea5b83c70d6
msgid "By the end of this tutorial, you will:"
msgstr "完成本教程后，您将能够："

#: ../../tutorials/uart_communication.rst:11 97a492495790486b9a2a1396f7797c2b
msgid "Configure UART peripherals with proper settings"
msgstr ""

#: ../../tutorials/uart_communication.rst:12 4db7d7674faf4f61b44ef4a1a3d8b8be
msgid "Send and receive data over UART"
msgstr ""

#: ../../tutorials/uart_communication.rst:13 41f015332a94403585728cdcdac0956a
msgid "Implement simple communication protocols"
msgstr ""

#: ../../tutorials/uart_communication.rst:14 497df3d947754123929d8cf81ee253ba
msgid "Handle UART errors and timeouts"
msgstr ""

#: ../../tutorials/uart_communication.rst:15 df724de3f52d48878e148bca073539e8
msgid "Use UART for debugging and logging"
msgstr ""

#: ../../tutorials/uart_communication.rst:18 251c33d0bea74cba9612c897579cd7aa
msgid "Prerequisites"
msgstr "前置条件"

#: ../../tutorials/uart_communication.rst:20 3760fee3d10e4d1291a1ada76b842da3
msgid "Completed :doc:`first_application` and :doc:`gpio_control` tutorials"
msgstr ""

#: ../../tutorials/uart_communication.rst:21 c6927da65fe34e5b9e0ca58ecac66d3a
msgid "STM32F4 Discovery board or compatible hardware"
msgstr "STM32F4 Discovery 板或兼容硬件"

#: ../../tutorials/uart_communication.rst:22 90695b93ddb24f5ba805948addd3814f
msgid "USB-to-Serial adapter (FTDI, CP2102, etc.) or ST-Link virtual COM port"
msgstr ""
"USB-to-Serial adapter (FTDI, CP2102, etc.) or ST-Link virtual COM port"

#: ../../tutorials/uart_communication.rst:23 e5daca9b6e364f0eb66fd19ce95f6dd8
msgid "Serial terminal software (PuTTY, minicom, screen, etc.)"
msgstr "Serial terminal software (PuTTY, minicom, screen, etc.)"

#: ../../tutorials/uart_communication.rst:26 9ed7c4f734494872adad9cdf107a90ab
msgid "Hardware Setup"
msgstr "硬件设置"

#: ../../tutorials/uart_communication.rst:28 a710a34a4c844d5d990c418cb1eef328
msgid "**STM32F4 Discovery UART2 Pins:**"
msgstr "**STM32F4 Discovery UART2 Pins:**"

#: ../../tutorials/uart_communication.rst:30 e0c61de262394440ba90b655c62d03e6
msgid "PA2: UART2 TX (transmit)"
msgstr "PA2: UART2 TX (transmit)"

#: ../../tutorials/uart_communication.rst:31 24432852c4f746fa9bfca033c16e3b71
msgid "PA3: UART2 RX (receive)"
msgstr "PA3: UART2 RX (receive)"

#: ../../tutorials/uart_communication.rst:32 05f8d3a8ecb84b4baa40fa05d73d0c7c
msgid "GND: Ground"
msgstr ""

#: ../../tutorials/uart_communication.rst:34 466f72788a7f43159919e4de40ede3f0
msgid "**Wiring:**"
msgstr "**Wiring:**"

#: ../../tutorials/uart_communication.rst:36 a8737499543343b683ab9dc034b460ca
msgid "Connect your USB-to-Serial adapter:"
msgstr ""

#: ../../tutorials/uart_communication.rst:38 825bc0bd0c2f471eb3bee9fddb91d094
msgid ""
"STM32F4          USB-Serial\n"
"-------          ----------\n"
"PA2 (TX)    -->  RX\n"
"PA3 (RX)    <--  TX\n"
"GND         ---  GND"
msgstr ""
"STM32F4          USB-Serial\n"
"-------          ----------\n"
"PA2 (TX)    -->  RX\n"
"PA3 (RX)    <--  TX\n"
"GND         ---  GND"

#: ../../tutorials/uart_communication.rst:47 7f149b5a34c44b6e82f05d059d6fb449
msgid ""
"Make sure voltage levels match! STM32F4 uses 3.3V logic. Most USB-Serial "
"adapters support 3.3V, but verify before connecting."
msgstr ""

#: ../../tutorials/uart_communication.rst:49 8139c9cc24a74ca1816c808bed3aaa7f
msgid "**Serial Terminal Settings:**"
msgstr "**Serial Terminal Settings:**"

#: ../../tutorials/uart_communication.rst:51 026ffd10abcf4c50be942e39d9835df5
msgid "Baud rate: 115200"
msgstr ""

#: ../../tutorials/uart_communication.rst:52 472cb3504d44401b9a4b9f9277528aea
msgid "Data bits: 8"
msgstr ""

#: ../../tutorials/uart_communication.rst:53 43d14ca05f674c35af82a55f8b5ad508
msgid "Stop bits: 1"
msgstr ""

#: ../../tutorials/uart_communication.rst:54 660009f79aa64612987258902b52d70d
msgid "Parity: None"
msgstr ""

#: ../../tutorials/uart_communication.rst:55 de47a2303312469085a6d2764040d6dc
msgid "Flow control: None"
msgstr ""

#: ../../tutorials/uart_communication.rst:58 bc8cbaab23d84147aa059126e4ab4fdd
msgid "Part 1: Basic UART Transmission"
msgstr ""

#: ../../tutorials/uart_communication.rst:60 d1bd4c5f72a2499a9245b88ece28ca3d
msgid "Let's start by sending data over UART."
msgstr ""

#: ../../tutorials/uart_communication.rst:63 f4cc3bdabbf34fb5814c0d1ab33b2358
#, fuzzy
msgid "UART Communication Workflow"
msgstr "UART Communication 教程"

#: ../../tutorials/uart_communication.rst:65 a0855dfe6a1b4aad8a742991d4e17bae
msgid "The following diagram shows the complete UART communication workflow:"
msgstr ""

#: ../../tutorials/uart_communication.rst:106 da2ead3aa83840248a9cd0aa4572fca3
msgid "Simple \"Hello World\""
msgstr ""

#: ../../tutorials/uart_communication.rst:108 91e644d3fb5c4fd59e26234408d35796
msgid ""
"#include \"hal/hal.h\"\n"
"#include <string.h>\n"
"\n"
"#define UART_ID  HAL_UART_1  /* UART1 or UART2 depending on platform */\n"
"\n"
"int main(void) {\n"
"    /* Initialize HAL */\n"
"    hal_init();\n"
"\n"
"    /* Configure UART */\n"
"    hal_uart_config_t uart_config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"\n"
"    /* Initialize UART */\n"
"    if (hal_uart_init(UART_ID, &uart_config) != HAL_OK) {\n"
"        /* Error: blink LED */\n"
"        while (1) {\n"
"            hal_gpio_toggle(HAL_GPIO_PORT_D, 14);  /* Red LED */\n"
"            hal_delay_ms(100);\n"
"        }\n"
"    }\n"
"\n"
"    /* Send message */\n"
"    const char* message = \"Hello, Nexus!\\r\\n\";\n"
"    hal_uart_write(UART_ID, (const uint8_t*)message, strlen(message), 1000);\n"
"\n"
"    /* Main loop */\n"
"    while (1) {\n"
"        hal_delay_ms(1000);\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"#include \"hal/hal.h\"\n"
"#include <string.h>\n"
"\n"
"#define UART_ID  HAL_UART_1  /* UART1 or UART2 depending on platform */\n"
"\n"
"int main(void) {\n"
"    /* Initialize HAL */\n"
"    hal_init();\n"
"\n"
"    /* Configure UART */\n"
"    hal_uart_config_t uart_config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"\n"
"    /* Initialize UART */\n"
"    if (hal_uart_init(UART_ID, &uart_config) != HAL_OK) {\n"
"        /* Error: blink LED */\n"
"        while (1) {\n"
"            hal_gpio_toggle(HAL_GPIO_PORT_D, 14);  /* Red LED */\n"
"            hal_delay_ms(100);\n"
"        }\n"
"    }\n"
"\n"
"    /* Send message */\n"
"    const char* message = \"Hello, Nexus!\\r\\n\";\n"
"    hal_uart_write(UART_ID, (const uint8_t*)message, strlen(message), 1000);\n"
"\n"
"    /* Main loop */\n"
"    while (1) {\n"
"        hal_delay_ms(1000);\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/uart_communication.rst:149 33f3f70c14444668b27ec20af3dd69cc
msgid "**Key Points:**"
msgstr "**Key Points:**"

#: ../../tutorials/uart_communication.rst:151 41797108bee24af4a7f8b35de5e8cdcc
msgid "``hal_uart_init()`` configures the UART peripheral"
msgstr "``hal_uart_init()`` configures the UART peripheral"

#: ../../tutorials/uart_communication.rst:152 4f965d822dfe4179a933de1e82b4feed
msgid "``hal_uart_write()`` sends data with a timeout (in milliseconds)"
msgstr "``hal_uart_write()`` sends data with a timeout (in milliseconds)"

#: ../../tutorials/uart_communication.rst:153 1b78a1a362634ec8b499236369619bc7
msgid "Use ``\\r\\n`` for proper line endings in terminal"
msgstr ""

#: ../../tutorials/uart_communication.rst:156 f8383e42f0d843a9af2bb25d45da26f6
msgid "Sending Formatted Output"
msgstr ""

#: ../../tutorials/uart_communication.rst:158 ae5cbda06b274024bdf295d1fc5ae932
msgid "Create a printf-like function for UART:"
msgstr ""

#: ../../tutorials/uart_communication.rst:160 9c4f39bb29ff485db5153390893dd390
#, python-format
msgid ""
"#include <stdio.h>\n"
"#include <stdarg.h>\n"
"\n"
"/**\n"
" * \\brief           Print formatted string to UART\n"
" * \\param[in]       fmt: Format string (printf-style)\n"
" * \\param[in]       ...: Variable arguments\n"
" */\n"
"static void uart_printf(const char* fmt, ...) {\n"
"    char buffer[128];\n"
"    va_list args;\n"
"\n"
"    va_start(args, fmt);\n"
"    int len = vsnprintf(buffer, sizeof(buffer), fmt, args);\n"
"    va_end(args);\n"
"\n"
"    if (len > 0) {\n"
"        hal_uart_write(UART_ID, (uint8_t*)buffer, len, 1000);\n"
"    }\n"
"}\n"
"\n"
"/* Usage */\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    hal_uart_config_t config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"    hal_uart_init(UART_ID, &config);\n"
"\n"
"    /* Print various data types */\n"
"    uart_printf(\"System initialized\\r\\n\");\n"
"    uart_printf(\"Tick: %lu ms\\r\\n\", (unsigned long)hal_get_tick());\n"
"    uart_printf(\"Temperature: %.2f C\\r\\n\", 25.5);\n"
"    uart_printf(\"Status: 0x%08X\\r\\n\", 0x12345678);\n"
"\n"
"    while (1) {\n"
"        hal_delay_ms(1000);\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"#include <stdio.h>\n"
"#include <stdarg.h>\n"
"\n"
"/**\n"
" * \\brief           Print formatted string to UART\n"
" * \\param[in]       fmt: Format string (printf-style)\n"
" * \\param[in]       ...: Variable arguments\n"
" */\n"
"static void uart_printf(const char* fmt, ...) {\n"
"    char buffer[128];\n"
"    va_list args;\n"
"\n"
"    va_start(args, fmt);\n"
"    int len = vsnprintf(buffer, sizeof(buffer), fmt, args);\n"
"    va_end(args);\n"
"\n"
"    if (len > 0) {\n"
"        hal_uart_write(UART_ID, (uint8_t*)buffer, len, 1000);\n"
"    }\n"
"}\n"
"\n"
"/* Usage */\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    hal_uart_config_t config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"    hal_uart_init(UART_ID, &config);\n"
"\n"
"    /* Print various data types */\n"
"    uart_printf(\"System initialized\\r\\n\");\n"
"    uart_printf(\"Tick: %lu ms\\r\\n\", (unsigned long)hal_get_tick());\n"
"    uart_printf(\"Temperature: %.2f C\\r\\n\", 25.5);\n"
"    uart_printf(\"Status: 0x%08X\\r\\n\", 0x12345678);\n"
"\n"
"    while (1) {\n"
"        hal_delay_ms(1000);\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/uart_communication.rst:210 685cb4e92cb0405aa29bc6a76219d9a5
msgid "Part 2: Receiving UART Data"
msgstr ""

#: ../../tutorials/uart_communication.rst:213 170ce92ee03f4483aa7c98223aed0982
msgid "Blocking Receive"
msgstr ""

#: ../../tutorials/uart_communication.rst:215 45619c1902d84bd497f48541a5b76409
msgid "Receive data with a timeout:"
msgstr ""

#: ../../tutorials/uart_communication.rst:217 0a8e5c2b0350460ea0da8161778ff289
#, python-format
msgid ""
"/**\n"
" * \\brief           Receive and echo data\n"
" */\n"
"static void uart_echo_demo(void) {\n"
"    uint8_t rx_byte;\n"
"    hal_status_t status;\n"
"\n"
"    uart_printf(\"Echo demo - type something:\\r\\n\");\n"
"\n"
"    while (1) {\n"
"        /* Receive one byte with 1 second timeout */\n"
"        status = hal_uart_read(UART_ID, &rx_byte, 1, 1000);\n"
"\n"
"        if (status == HAL_OK) {\n"
"            /* Echo received byte */\n"
"            hal_uart_write(UART_ID, &rx_byte, 1, 100);\n"
"\n"
"            /* Check for Enter key */\n"
"            if (rx_byte == '\\r' || rx_byte == '\\n') {\n"
"                uart_printf(\"\\r\\n\");\n"
"            }\n"
"        } else if (status == HAL_ERR_TIMEOUT) {\n"
"            /* Timeout - no data received */\n"
"            uart_printf(\".\");  /* Heartbeat */\n"
"        } else {\n"
"            /* Error */\n"
"            uart_printf(\"Error: %d\\r\\n\", status);\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"/**\n"
" * \\brief           Receive and echo data\n"
" */\n"
"static void uart_echo_demo(void) {\n"
"    uint8_t rx_byte;\n"
"    hal_status_t status;\n"
"\n"
"    uart_printf(\"Echo demo - type something:\\r\\n\");\n"
"\n"
"    while (1) {\n"
"        /* Receive one byte with 1 second timeout */\n"
"        status = hal_uart_read(UART_ID, &rx_byte, 1, 1000);\n"
"\n"
"        if (status == HAL_OK) {\n"
"            /* Echo received byte */\n"
"            hal_uart_write(UART_ID, &rx_byte, 1, 100);\n"
"\n"
"            /* Check for Enter key */\n"
"            if (rx_byte == '\\r' || rx_byte == '\\n') {\n"
"                uart_printf(\"\\r\\n\");\n"
"            }\n"
"        } else if (status == HAL_ERR_TIMEOUT) {\n"
"            /* Timeout - no data received */\n"
"            uart_printf(\".\");  /* Heartbeat */\n"
"        } else {\n"
"            /* Error */\n"
"            uart_printf(\"Error: %d\\r\\n\", status);\n"
"        }\n"
"    }\n"
"}"

#: ../../tutorials/uart_communication.rst:251 5136ceb766834957bc7a243717f7d0ba
msgid "Line-Based Input"
msgstr ""

#: ../../tutorials/uart_communication.rst:253 a990b5e63ed6423f9e6c8f4146f7bca4
msgid "Receive complete lines of text:"
msgstr ""

#: ../../tutorials/uart_communication.rst:255 0eef9de5424140f7b1d6005a98721a5a
#, python-format
msgid ""
"#define LINE_BUFFER_SIZE  128\n"
"\n"
"/**\n"
" * \\brief           Read a line from UART\n"
" * \\param[out]      buffer: Buffer to store line\n"
" * \\param[in]       size: Buffer size\n"
" * \\param[in]       timeout_ms: Timeout in milliseconds\n"
" * \\return          Number of characters read, or -1 on error\n"
" */\n"
"static int uart_read_line(char* buffer, size_t size, uint32_t timeout_ms) {\n"
"    size_t index = 0;\n"
"    uint32_t start_time = hal_get_tick();\n"
"\n"
"    while (index < (size - 1)) {\n"
"        /* Check timeout */\n"
"        if ((hal_get_tick() - start_time) > timeout_ms) {\n"
"            return -1;  /* Timeout */\n"
"        }\n"
"\n"
"        /* Read one byte */\n"
"        uint8_t ch;\n"
"        if (hal_uart_read(UART_ID, &ch, 1, 100) == HAL_OK) {\n"
"            /* Check for line ending */\n"
"            if (ch == '\\r' || ch == '\\n') {\n"
"                buffer[index] = '\\0';\n"
"                return index;\n"
"            }\n"
"\n"
"            /* Check for backspace */\n"
"            if (ch == '\\b' || ch == 127) {\n"
"                if (index > 0) {\n"
"                    index--;\n"
"                    uart_printf(\"\\b \\b\");  /* Erase character on terminal */\n"
"                }\n"
"                continue;\n"
"            }\n"
"\n"
"            /* Store character */\n"
"            buffer[index++] = ch;\n"
"\n"
"            /* Echo character */\n"
"            hal_uart_write(UART_ID, &ch, 1, 100);\n"
"        }\n"
"    }\n"
"\n"
"    buffer[index] = '\\0';\n"
"    return index;\n"
"}\n"
"\n"
"/* Usage */\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    hal_uart_config_t config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"    hal_uart_init(UART_ID, &config);\n"
"\n"
"    char line[LINE_BUFFER_SIZE];\n"
"\n"
"    uart_printf(\"Enter your name: \");\n"
"\n"
"    if (uart_read_line(line, sizeof(line), 30000) > 0) {\n"
"        uart_printf(\"\\r\\nHello, %s!\\r\\n\", line);\n"
"    } else {\n"
"        uart_printf(\"\\r\\nTimeout!\\r\\n\");\n"
"    }\n"
"\n"
"    while (1) {\n"
"        hal_delay_ms(1000);\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"#define LINE_BUFFER_SIZE  128\n"
"\n"
"/**\n"
" * \\brief           Read a line from UART\n"
" * \\param[out]      buffer: Buffer to store line\n"
" * \\param[in]       size: Buffer size\n"
" * \\param[in]       timeout_ms: Timeout in milliseconds\n"
" * \\return          Number of characters read, or -1 on error\n"
" */\n"
"static int uart_read_line(char* buffer, size_t size, uint32_t timeout_ms) {\n"
"    size_t index = 0;\n"
"    uint32_t start_time = hal_get_tick();\n"
"\n"
"    while (index < (size - 1)) {\n"
"        /* Check timeout */\n"
"        if ((hal_get_tick() - start_time) > timeout_ms) {\n"
"            return -1;  /* Timeout */\n"
"        }\n"
"\n"
"        /* Read one byte */\n"
"        uint8_t ch;\n"
"        if (hal_uart_read(UART_ID, &ch, 1, 100) == HAL_OK) {\n"
"            /* Check for line ending */\n"
"            if (ch == '\\r' || ch == '\\n') {\n"
"                buffer[index] = '\\0';\n"
"                return index;\n"
"            }\n"
"\n"
"            /* Check for backspace */\n"
"            if (ch == '\\b' || ch == 127) {\n"
"                if (index > 0) {\n"
"                    index--;\n"
"                    uart_printf(\"\\b \\b\");  /* Erase character on terminal */\n"
"                }\n"
"                continue;\n"
"            }\n"
"\n"
"            /* Store character */\n"
"            buffer[index++] = ch;\n"
"\n"
"            /* Echo character */\n"
"            hal_uart_write(UART_ID, &ch, 1, 100);\n"
"        }\n"
"    }\n"
"\n"
"    buffer[index] = '\\0';\n"
"    return index;\n"
"}\n"
"\n"
"/* Usage */\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    hal_uart_config_t config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"    hal_uart_init(UART_ID, &config);\n"
"\n"
"    char line[LINE_BUFFER_SIZE];\n"
"\n"
"    uart_printf(\"Enter your name: \");\n"
"\n"
"    if (uart_read_line(line, sizeof(line), 30000) > 0) {\n"
"        uart_printf(\"\\r\\nHello, %s!\\r\\n\", line);\n"
"    } else {\n"
"        uart_printf(\"\\r\\nTimeout!\\r\\n\");\n"
"    }\n"
"\n"
"    while (1) {\n"
"        hal_delay_ms(1000);\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/uart_communication.rst:337 94c8f90e16124d2abb1d23aeca157ea7
msgid "Part 3: Command-Line Interface"
msgstr ""

#: ../../tutorials/uart_communication.rst:339 8c04b1bbbef9405f823056ac504d7bfd
msgid "Build a simple CLI over UART:"
msgstr ""

#: ../../tutorials/uart_communication.rst:341 c77b6439289e497db0afae1b8385f6bf
#, python-format
msgid ""
"#include <string.h>\n"
"#include <stdlib.h>\n"
"\n"
"/**\n"
" * \\brief           Parse and execute command\n"
" * \\param[in]       cmd: Command string\n"
" */\n"
"static void execute_command(const char* cmd) {\n"
"    /* Skip leading whitespace */\n"
"    while (*cmd == ' ') cmd++;\n"
"\n"
"    if (strlen(cmd) == 0) {\n"
"        return;  /* Empty command */\n"
"    }\n"
"\n"
"    /* Help command */\n"
"    if (strcmp(cmd, \"help\") == 0) {\n"
"        uart_printf(\"Available commands:\\r\\n\");\n"
"        uart_printf(\"  help     - Show this help\\r\\n\");\n"
"        uart_printf(\"  led on   - Turn on LED\\r\\n\");\n"
"        uart_printf(\"  led off  - Turn off LED\\r\\n\");\n"
"        uart_printf(\"  tick     - Show system tick\\r\\n\");\n"
"        uart_printf(\"  reset    - Reset system\\r\\n\");\n"
"    }\n"
"    /* LED commands */\n"
"    else if (strncmp(cmd, \"led \", 4) == 0) {\n"
"        const char* arg = cmd + 4;\n"
"        if (strcmp(arg, \"on\") == 0) {\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 12, HAL_GPIO_LEVEL_HIGH);\n"
"            uart_printf(\"LED ON\\r\\n\");\n"
"        } else if (strcmp(arg, \"off\") == 0) {\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 12, HAL_GPIO_LEVEL_LOW);\n"
"            uart_printf(\"LED OFF\\r\\n\");\n"
"        } else {\n"
"            uart_printf(\"Usage: led <on|off>\\r\\n\");\n"
"        }\n"
"    }\n"
"    /* Tick command */\n"
"    else if (strcmp(cmd, \"tick\") == 0) {\n"
"        uart_printf(\"System tick: %lu ms\\r\\n\", (unsigned long)hal_get_tick());\n"
"    }\n"
"    /* Reset command */\n"
"    else if (strcmp(cmd, \"reset\") == 0) {\n"
"        uart_printf(\"Resetting...\\r\\n\");\n"
"        hal_delay_ms(100);\n"
"        hal_system_reset();\n"
"    }\n"
"    /* Unknown command */\n"
"    else {\n"
"        uart_printf(\"Unknown command: %s\\r\\n\", cmd);\n"
"        uart_printf(\"Type 'help' for available commands\\r\\n\");\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           CLI main loop\n"
" */\n"
"static void cli_loop(void) {\n"
"    char line[LINE_BUFFER_SIZE];\n"
"\n"
"    uart_printf(\"\\r\\n\");\n"
"    uart_printf(\"========================================\\r\\n\");\n"
"    uart_printf(\"  Nexus UART CLI Demo\\r\\n\");\n"
"    uart_printf(\"  Type 'help' for commands\\r\\n\");\n"
"    uart_printf(\"========================================\\r\\n\");\n"
"\n"
"    while (1) {\n"
"        uart_printf(\"\\r\\nnexus> \");\n"
"\n"
"        if (uart_read_line(line, sizeof(line), 60000) > 0) {\n"
"            uart_printf(\"\\r\\n\");\n"
"            execute_command(line);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize LED */\n"
"    hal_gpio_config_t led_config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &led_config);\n"
"\n"
"    /* Initialize UART */\n"
"    hal_uart_config_t uart_config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"    hal_uart_init(UART_ID, &uart_config);\n"
"\n"
"    /* Run CLI */\n"
"    cli_loop();\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"#include <string.h>\n"
"#include <stdlib.h>\n"
"\n"
"/**\n"
" * \\brief           Parse and execute command\n"
" * \\param[in]       cmd: Command string\n"
" */\n"
"static void execute_command(const char* cmd) {\n"
"    /* Skip leading whitespace */\n"
"    while (*cmd == ' ') cmd++;\n"
"\n"
"    if (strlen(cmd) == 0) {\n"
"        return;  /* Empty command */\n"
"    }\n"
"\n"
"    /* Help command */\n"
"    if (strcmp(cmd, \"help\") == 0) {\n"
"        uart_printf(\"Available commands:\\r\\n\");\n"
"        uart_printf(\"  help     - Show this help\\r\\n\");\n"
"        uart_printf(\"  led on   - Turn on LED\\r\\n\");\n"
"        uart_printf(\"  led off  - Turn off LED\\r\\n\");\n"
"        uart_printf(\"  tick     - Show system tick\\r\\n\");\n"
"        uart_printf(\"  reset    - Reset system\\r\\n\");\n"
"    }\n"
"    /* LED commands */\n"
"    else if (strncmp(cmd, \"led \", 4) == 0) {\n"
"        const char* arg = cmd + 4;\n"
"        if (strcmp(arg, \"on\") == 0) {\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 12, HAL_GPIO_LEVEL_HIGH);\n"
"            uart_printf(\"LED ON\\r\\n\");\n"
"        } else if (strcmp(arg, \"off\") == 0) {\n"
"            hal_gpio_write(HAL_GPIO_PORT_D, 12, HAL_GPIO_LEVEL_LOW);\n"
"            uart_printf(\"LED OFF\\r\\n\");\n"
"        } else {\n"
"            uart_printf(\"Usage: led <on|off>\\r\\n\");\n"
"        }\n"
"    }\n"
"    /* Tick command */\n"
"    else if (strcmp(cmd, \"tick\") == 0) {\n"
"        uart_printf(\"System tick: %lu ms\\r\\n\", (unsigned long)hal_get_tick());\n"
"    }\n"
"    /* Reset command */\n"
"    else if (strcmp(cmd, \"reset\") == 0) {\n"
"        uart_printf(\"Resetting...\\r\\n\");\n"
"        hal_delay_ms(100);\n"
"        hal_system_reset();\n"
"    }\n"
"    /* Unknown command */\n"
"    else {\n"
"        uart_printf(\"Unknown command: %s\\r\\n\", cmd);\n"
"        uart_printf(\"Type 'help' for available commands\\r\\n\");\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           CLI main loop\n"
" */\n"
"static void cli_loop(void) {\n"
"    char line[LINE_BUFFER_SIZE];\n"
"\n"
"    uart_printf(\"\\r\\n\");\n"
"    uart_printf(\"========================================\\r\\n\");\n"
"    uart_printf(\"  Nexus UART CLI Demo\\r\\n\");\n"
"    uart_printf(\"  Type 'help' for commands\\r\\n\");\n"
"    uart_printf(\"========================================\\r\\n\");\n"
"\n"
"    while (1) {\n"
"        uart_printf(\"\\r\\nnexus> \");\n"
"\n"
"        if (uart_read_line(line, sizeof(line), 60000) > 0) {\n"
"            uart_printf(\"\\r\\n\");\n"
"            execute_command(line);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    /* Initialize LED */\n"
"    hal_gpio_config_t led_config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    hal_gpio_init(HAL_GPIO_PORT_D, 12, &led_config);\n"
"\n"
"    /* Initialize UART */\n"
"    hal_uart_config_t uart_config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"    hal_uart_init(UART_ID, &uart_config);\n"
"\n"
"    /* Run CLI */\n"
"    cli_loop();\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/uart_communication.rst:449 4a761fb0efd54fd2b591681adc2f0238
msgid "Part 4: Binary Protocols"
msgstr ""

#: ../../tutorials/uart_communication.rst:452 ef4154f94fd04b18a36b71e0d7f95a5d
msgid "Implementing Packet-Based Communication"
msgstr ""

#: ../../tutorials/uart_communication.rst:454 39db40ed49de4f0ebc6429d9680b3212
#, python-format
msgid ""
"/**\n"
" * \\brief           Packet structure\n"
" */\n"
"typedef struct {\n"
"    uint8_t start_byte;     /* 0xAA */\n"
"    uint8_t cmd;            /* Command ID */\n"
"    uint8_t length;         /* Payload length */\n"
"    uint8_t payload[32];    /* Payload data */\n"
"    uint8_t checksum;       /* Simple checksum */\n"
"} __attribute__((packed)) packet_t;\n"
"\n"
"#define PACKET_START_BYTE  0xAA\n"
"\n"
"/**\n"
" * \\brief           Calculate checksum\n"
" */\n"
"static uint8_t calculate_checksum(const packet_t* pkt) {\n"
"    uint8_t sum = 0;\n"
"    sum += pkt->cmd;\n"
"    sum += pkt->length;\n"
"    for (uint8_t i = 0; i < pkt->length; i++) {\n"
"        sum += pkt->payload[i];\n"
"    }\n"
"    return sum;\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Send packet\n"
" */\n"
"static hal_status_t send_packet(uint8_t cmd, const uint8_t* data, uint8_t len) {\n"
"    packet_t pkt;\n"
"\n"
"    pkt.start_byte = PACKET_START_BYTE;\n"
"    pkt.cmd = cmd;\n"
"    pkt.length = len;\n"
"    memcpy(pkt.payload, data, len);\n"
"    pkt.checksum = calculate_checksum(&pkt);\n"
"\n"
"    size_t packet_size = 4 + len;  /* start + cmd + len + checksum + payload */\n"
"    return hal_uart_write(UART_ID, (uint8_t*)&pkt, packet_size, 1000);\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Receive packet\n"
" */\n"
"static hal_status_t receive_packet(packet_t* pkt, uint32_t timeout_ms) {\n"
"    uint32_t start_time = hal_get_tick();\n"
"\n"
"    /* Wait for start byte */\n"
"    while ((hal_get_tick() - start_time) < timeout_ms) {\n"
"        uint8_t byte;\n"
"        if (hal_uart_read(UART_ID, &byte, 1, 100) == HAL_OK) {\n"
"            if (byte == PACKET_START_BYTE) {\n"
"                pkt->start_byte = byte;\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    if (pkt->start_byte != PACKET_START_BYTE) {\n"
"        return HAL_ERR_TIMEOUT;\n"
"    }\n"
"\n"
"    /* Read command and length */\n"
"    if (hal_uart_read(UART_ID, &pkt->cmd, 1, 1000) != HAL_OK) {\n"
"        return HAL_ERR_TIMEOUT;\n"
"    }\n"
"    if (hal_uart_read(UART_ID, &pkt->length, 1, 1000) != HAL_OK) {\n"
"        return HAL_ERR_TIMEOUT;\n"
"    }\n"
"\n"
"    /* Validate length */\n"
"    if (pkt->length > sizeof(pkt->payload)) {\n"
"        return HAL_ERR_FAIL;\n"
"    }\n"
"\n"
"    /* Read payload */\n"
"    if (pkt->length > 0) {\n"
"        if (hal_uart_read(UART_ID, pkt->payload, pkt->length, 1000) != HAL_OK) {\n"
"            return HAL_ERR_TIMEOUT;\n"
"        }\n"
"    }\n"
"\n"
"    /* Read checksum */\n"
"    if (hal_uart_read(UART_ID, &pkt->checksum, 1, 1000) != HAL_OK) {\n"
"        return HAL_ERR_TIMEOUT;\n"
"    }\n"
"\n"
"    /* Verify checksum */\n"
"    uint8_t expected_checksum = calculate_checksum(pkt);\n"
"    if (pkt->checksum != expected_checksum) {\n"
"        return HAL_ERR_FAIL;  /* Checksum mismatch */\n"
"    }\n"
"\n"
"    return HAL_OK;\n"
"}\n"
"\n"
"/* Usage example */\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    hal_uart_config_t config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"    hal_uart_init(UART_ID, &config);\n"
"\n"
"    /* Send a packet */\n"
"    uint8_t data[] = {0x01, 0x02, 0x03, 0x04};\n"
"    send_packet(0x10, data, sizeof(data));\n"
"\n"
"    /* Receive packets */\n"
"    packet_t rx_pkt;\n"
"    while (1) {\n"
"        if (receive_packet(&rx_pkt, 5000) == HAL_OK) {\n"
"            uart_printf(\"Received packet: cmd=0x%02X, len=%d\\r\\n\",\n"
"                       rx_pkt.cmd, rx_pkt.length);\n"
"        }\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"/**\n"
" * \\brief           Packet structure\n"
" */\n"
"typedef struct {\n"
"    uint8_t start_byte;     /* 0xAA */\n"
"    uint8_t cmd;            /* Command ID */\n"
"    uint8_t length;         /* Payload length */\n"
"    uint8_t payload[32];    /* Payload data */\n"
"    uint8_t checksum;       /* Simple checksum */\n"
"} __attribute__((packed)) packet_t;\n"
"\n"
"#define PACKET_START_BYTE  0xAA\n"
"\n"
"/**\n"
" * \\brief           Calculate checksum\n"
" */\n"
"static uint8_t calculate_checksum(const packet_t* pkt) {\n"
"    uint8_t sum = 0;\n"
"    sum += pkt->cmd;\n"
"    sum += pkt->length;\n"
"    for (uint8_t i = 0; i < pkt->length; i++) {\n"
"        sum += pkt->payload[i];\n"
"    }\n"
"    return sum;\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Send packet\n"
" */\n"
"static hal_status_t send_packet(uint8_t cmd, const uint8_t* data, uint8_t len) {\n"
"    packet_t pkt;\n"
"\n"
"    pkt.start_byte = PACKET_START_BYTE;\n"
"    pkt.cmd = cmd;\n"
"    pkt.length = len;\n"
"    memcpy(pkt.payload, data, len);\n"
"    pkt.checksum = calculate_checksum(&pkt);\n"
"\n"
"    size_t packet_size = 4 + len;  /* start + cmd + len + checksum + payload */\n"
"    return hal_uart_write(UART_ID, (uint8_t*)&pkt, packet_size, 1000);\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Receive packet\n"
" */\n"
"static hal_status_t receive_packet(packet_t* pkt, uint32_t timeout_ms) {\n"
"    uint32_t start_time = hal_get_tick();\n"
"\n"
"    /* Wait for start byte */\n"
"    while ((hal_get_tick() - start_time) < timeout_ms) {\n"
"        uint8_t byte;\n"
"        if (hal_uart_read(UART_ID, &byte, 1, 100) == HAL_OK) {\n"
"            if (byte == PACKET_START_BYTE) {\n"
"                pkt->start_byte = byte;\n"
"                break;\n"
"            }\n"
"        }\n"
"    }\n"
"\n"
"    if (pkt->start_byte != PACKET_START_BYTE) {\n"
"        return HAL_ERR_TIMEOUT;\n"
"    }\n"
"\n"
"    /* Read command and length */\n"
"    if (hal_uart_read(UART_ID, &pkt->cmd, 1, 1000) != HAL_OK) {\n"
"        return HAL_ERR_TIMEOUT;\n"
"    }\n"
"    if (hal_uart_read(UART_ID, &pkt->length, 1, 1000) != HAL_OK) {\n"
"        return HAL_ERR_TIMEOUT;\n"
"    }\n"
"\n"
"    /* Validate length */\n"
"    if (pkt->length > sizeof(pkt->payload)) {\n"
"        return HAL_ERR_FAIL;\n"
"    }\n"
"\n"
"    /* Read payload */\n"
"    if (pkt->length > 0) {\n"
"        if (hal_uart_read(UART_ID, pkt->payload, pkt->length, 1000) != HAL_OK) {\n"
"            return HAL_ERR_TIMEOUT;\n"
"        }\n"
"    }\n"
"\n"
"    /* Read checksum */\n"
"    if (hal_uart_read(UART_ID, &pkt->checksum, 1, 1000) != HAL_OK) {\n"
"        return HAL_ERR_TIMEOUT;\n"
"    }\n"
"\n"
"    /* Verify checksum */\n"
"    uint8_t expected_checksum = calculate_checksum(pkt);\n"
"    if (pkt->checksum != expected_checksum) {\n"
"        return HAL_ERR_FAIL;  /* Checksum mismatch */\n"
"    }\n"
"\n"
"    return HAL_OK;\n"
"}\n"
"\n"
"/* Usage example */\n"
"int main(void) {\n"
"    hal_init();\n"
"\n"
"    hal_uart_config_t config = {\n"
"        .baudrate = 115200,\n"
"        .wordlen = HAL_UART_WORDLEN_8,\n"
"        .stopbits = HAL_UART_STOPBITS_1,\n"
"        .parity = HAL_UART_PARITY_NONE,\n"
"        .flowctrl = HAL_UART_FLOWCTRL_NONE\n"
"    };\n"
"    hal_uart_init(UART_ID, &config);\n"
"\n"
"    /* Send a packet */\n"
"    uint8_t data[] = {0x01, 0x02, 0x03, 0x04};\n"
"    send_packet(0x10, data, sizeof(data));\n"
"\n"
"    /* Receive packets */\n"
"    packet_t rx_pkt;\n"
"    while (1) {\n"
"        if (receive_packet(&rx_pkt, 5000) == HAL_OK) {\n"
"            uart_printf(\"Received packet: cmd=0x%02X, len=%d\\r\\n\",\n"
"                       rx_pkt.cmd, rx_pkt.length);\n"
"        }\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/uart_communication.rst:583 94e3e1f039694ab9b460c6e4ec7e7c04
msgid "Part 5: Error Handling"
msgstr ""

#: ../../tutorials/uart_communication.rst:586 8bc750f6837d4791893b5947ac065e51
msgid "Handling UART Errors"
msgstr ""

#: ../../tutorials/uart_communication.rst:588 ad5289ca9cfc465baf3c64b741ceb860
msgid ""
"/**\n"
" * \\brief           Check and handle UART errors\n"
" */\n"
"static void check_uart_errors(void) {\n"
"    hal_uart_error_t errors = hal_uart_get_errors(UART_ID);\n"
"\n"
"    if (errors & HAL_UART_ERROR_OVERRUN) {\n"
"        uart_printf(\"Error: Overrun\\r\\n\");\n"
"        /* Data was lost because it wasn't read fast enough */\n"
"    }\n"
"\n"
"    if (errors & HAL_UART_ERROR_FRAMING) {\n"
"        uart_printf(\"Error: Framing\\r\\n\");\n"
"        /* Invalid stop bit - possible baud rate mismatch */\n"
"    }\n"
"\n"
"    if (errors & HAL_UART_ERROR_PARITY) {\n"
"        uart_printf(\"Error: Parity\\r\\n\");\n"
"        /* Parity check failed */\n"
"    }\n"
"\n"
"    if (errors & HAL_UART_ERROR_NOISE) {\n"
"        uart_printf(\"Error: Noise\\r\\n\");\n"
"        /* Noise detected on line */\n"
"    }\n"
"\n"
"    /* Clear errors */\n"
"    if (errors != HAL_UART_ERROR_NONE) {\n"
"        hal_uart_clear_errors(UART_ID);\n"
"    }\n"
"}"
msgstr ""
"/**\n"
" * \\brief           Check and handle UART errors\n"
" */\n"
"static void check_uart_errors(void) {\n"
"    hal_uart_error_t errors = hal_uart_get_errors(UART_ID);\n"
"\n"
"    if (errors & HAL_UART_ERROR_OVERRUN) {\n"
"        uart_printf(\"Error: Overrun\\r\\n\");\n"
"        /* Data was lost because it wasn't read fast enough */\n"
"    }\n"
"\n"
"    if (errors & HAL_UART_ERROR_FRAMING) {\n"
"        uart_printf(\"Error: Framing\\r\\n\");\n"
"        /* Invalid stop bit - possible baud rate mismatch */\n"
"    }\n"
"\n"
"    if (errors & HAL_UART_ERROR_PARITY) {\n"
"        uart_printf(\"Error: Parity\\r\\n\");\n"
"        /* Parity check failed */\n"
"    }\n"
"\n"
"    if (errors & HAL_UART_ERROR_NOISE) {\n"
"        uart_printf(\"Error: Noise\\r\\n\");\n"
"        /* Noise detected on line */\n"
"    }\n"
"\n"
"    /* Clear errors */\n"
"    if (errors != HAL_UART_ERROR_NONE) {\n"
"        hal_uart_clear_errors(UART_ID);\n"
"    }\n"
"}"

#: ../../tutorials/uart_communication.rst:623 c768f6aa1710467c88e7906338283039
msgid "Part 6: Debugging with UART"
msgstr ""

#: ../../tutorials/uart_communication.rst:626 ba7b05a77b734393bab0c4cb226f9251
msgid "Using UART for Debug Output"
msgstr ""

#: ../../tutorials/uart_communication.rst:628 e80b7c7cc20748818b20b2164e1ec03b
#, python-format
msgid ""
"/* Debug macros */\n"
"#define DEBUG_ENABLED  1\n"
"\n"
"#if DEBUG_ENABLED\n"
"#define DEBUG_PRINT(fmt, ...)  uart_printf(\"[DEBUG] \" fmt, ##__VA_ARGS__)\n"
"#define DEBUG_ERROR(fmt, ...)  uart_printf(\"[ERROR] \" fmt, ##__VA_ARGS__)\n"
"#define DEBUG_INFO(fmt, ...)   uart_printf(\"[INFO] \" fmt, ##__VA_ARGS__)\n"
"#else\n"
"#define DEBUG_PRINT(fmt, ...)\n"
"#define DEBUG_ERROR(fmt, ...)\n"
"#define DEBUG_INFO(fmt, ...)\n"
"#endif\n"
"\n"
"/* Usage */\n"
"void some_function(void) {\n"
"    DEBUG_INFO(\"Entering function\\r\\n\");\n"
"\n"
"    int result = do_something();\n"
"\n"
"    if (result < 0) {\n"
"        DEBUG_ERROR(\"Operation failed: %d\\r\\n\", result);\n"
"    } else {\n"
"        DEBUG_PRINT(\"Result: %d\\r\\n\", result);\n"
"    }\n"
"}"
msgstr ""
"/* Debug macros */\n"
"#define DEBUG_ENABLED  1\n"
"\n"
"#if DEBUG_ENABLED\n"
"#define DEBUG_PRINT(fmt, ...)  uart_printf(\"[DEBUG] \" fmt, ##__VA_ARGS__)\n"
"#define DEBUG_ERROR(fmt, ...)  uart_printf(\"[ERROR] \" fmt, ##__VA_ARGS__)\n"
"#define DEBUG_INFO(fmt, ...)   uart_printf(\"[INFO] \" fmt, ##__VA_ARGS__)\n"
"#else\n"
"#define DEBUG_PRINT(fmt, ...)\n"
"#define DEBUG_ERROR(fmt, ...)\n"
"#define DEBUG_INFO(fmt, ...)\n"
"#endif\n"
"\n"
"/* Usage */\n"
"void some_function(void) {\n"
"    DEBUG_INFO(\"Entering function\\r\\n\");\n"
"\n"
"    int result = do_something();\n"
"\n"
"    if (result < 0) {\n"
"        DEBUG_ERROR(\"Operation failed: %d\\r\\n\", result);\n"
"    } else {\n"
"        DEBUG_PRINT(\"Result: %d\\r\\n\", result);\n"
"    }\n"
"}"

#: ../../tutorials/uart_communication.rst:657 b5139cc4c18c4794aa6b9922f2c749b9
msgid "Best Practices"
msgstr "最佳实践"

#: ../../tutorials/uart_communication.rst:659 28b2ad6e9de34e479c05c333dd28659d
msgid "**Always Check Return Values**: UART operations can fail or timeout"
msgstr ""

#: ../../tutorials/uart_communication.rst:661 a234dda8e82a4151b7b64a2c49f4352e
msgid "**Use Appropriate Timeouts**: Balance responsiveness vs. reliability"
msgstr ""

#: ../../tutorials/uart_communication.rst:663 3cb0a7b445a345a0992051ea9254c495
msgid "**Handle Errors**: Check for and handle UART errors"
msgstr ""

#: ../../tutorials/uart_communication.rst:665 fb0d80ae8f9641bcb7f3c38b60dc0a7a
msgid ""
"**Buffer Management**: Use appropriate buffer sizes for your application"
msgstr ""

#: ../../tutorials/uart_communication.rst:667 5d7983e5b59e4aefb5f0d327ed176d87
msgid ""
"**Flow Control**: Consider hardware flow control for high-speed "
"communication"
msgstr ""

#: ../../tutorials/uart_communication.rst:669 030fea7845b849f39da9db731c11afda
msgid "**Baud Rate**: Choose a baud rate supported by both devices"
msgstr ""

#: ../../tutorials/uart_communication.rst:671 1db61d5ccd6e4f74bcafdc729bb850c5
msgid "**Line Endings**: Use ``\\r\\n`` for compatibility with most terminals"
msgstr ""

#: ../../tutorials/uart_communication.rst:674 961a23a726db431c934727a5e203e7b3
msgid "Common Issues"
msgstr "常见问题"

#: ../../tutorials/uart_communication.rst:676 8a61db0d14484fb7bc1d852fd5856b6f
msgid "**No Output on Terminal:**"
msgstr "**No Output on Terminal:**"

#: ../../tutorials/uart_communication.rst:678 b14c51b5c2d74fb6ae19bcf754d58036
msgid "Check wiring (TX/RX crossed correctly)"
msgstr "Check wiring (TX/RX crossed correctly)"

#: ../../tutorials/uart_communication.rst:679 13101c40d45349c5aa20da2aaf00b345
msgid "Verify baud rate matches on both sides"
msgstr ""

#: ../../tutorials/uart_communication.rst:680 d6bc7150fbc24838aaee23347117ae55
msgid "Ensure correct UART peripheral is initialized"
msgstr ""

#: ../../tutorials/uart_communication.rst:681 c6154dabc3644d91a10fd9353dba25ff
msgid "Check that terminal is connected to correct COM port"
msgstr ""

#: ../../tutorials/uart_communication.rst:683 cafb48f373a544378547886bbae40546
msgid "**Garbled Output:**"
msgstr "**Garbled Output:**"

#: ../../tutorials/uart_communication.rst:685 db7fdaa3d23c41f2af4adc729af52ed4
msgid "Baud rate mismatch"
msgstr ""

#: ../../tutorials/uart_communication.rst:686 1918a86a894a4ccfa1f8455769d1a44d
msgid "Wrong data bits, stop bits, or parity settings"
msgstr ""

#: ../../tutorials/uart_communication.rst:687 ab24cc194f4e4fbab5ba104c66f70495
msgid "Clock configuration issue"
msgstr "时钟 configuration issue"

#: ../../tutorials/uart_communication.rst:689 937197b741054506b5cbc71a57892c4e
msgid "**Data Loss:**"
msgstr "**Data Loss:**"

#: ../../tutorials/uart_communication.rst:691 3c70880aacd94066b7157a567ee135a4
msgid "Increase buffer sizes"
msgstr ""

#: ../../tutorials/uart_communication.rst:692 1b46a3735d1f45b9b046185d5bec57ec
msgid "Reduce baud rate"
msgstr ""

#: ../../tutorials/uart_communication.rst:693 91e4d1cf7744494fa63d2600126ae5a6
msgid "Implement flow control"
msgstr ""

#: ../../tutorials/uart_communication.rst:694 d51dffffabbe4f8b8884349e0fddbbae
msgid "Process received data faster"
msgstr ""

#: ../../tutorials/uart_communication.rst:696 59f7de7fe6a542e0b83f7e3054d3baec
msgid "**Timeout Errors:**"
msgstr "**Timeout Errors:**"

#: ../../tutorials/uart_communication.rst:698 6c87d54f935c4beb9b295d89500d3f13
msgid "Increase timeout values"
msgstr ""

#: ../../tutorials/uart_communication.rst:699 0010ff30c0d84d919d75d098a0684d52
msgid "Check that sender is actually sending data"
msgstr ""

#: ../../tutorials/uart_communication.rst:700 627216c54cce49b5a497aff41fd52b1b
msgid "Verify wiring and connections"
msgstr ""

#: ../../tutorials/uart_communication.rst:703 8bcecf05330345369005007bd602ccb0
msgid "Next Steps"
msgstr "下一步"

#: ../../tutorials/uart_communication.rst:705 2e49b179abc149adb5ed5cc7b306b7f4
msgid ":doc:`task_creation` - Add multi-tasking with OSAL"
msgstr ":doc:`task_creation` - Add multi-tasking with OSAL"

#: ../../tutorials/uart_communication.rst:706 a8b4ea10efce41dcba5a743d29700043
msgid ""
":doc:`../user_guide/log` - Use the Log framework for structured logging"
msgstr ""
":doc:`../user_guide/log` - Use the Log framework for structured logging"

#: ../../tutorials/uart_communication.rst:707 08272d7eefbf48e0b4fa9730bcaace46
msgid ":doc:`../user_guide/shell` - Use the Shell framework for advanced CLI"
msgstr ":doc:`../user_guide/shell` - Use the Shell framework for advanced CLI"

#: ../../tutorials/uart_communication.rst:708 32c9541d55584f66b70e61f205aca3be
msgid ":doc:`../platform_guides/stm32f4` - Platform-specific UART details"
msgstr ":doc:`../platform_guides/stm32f4` - Platform-specific UART details"
