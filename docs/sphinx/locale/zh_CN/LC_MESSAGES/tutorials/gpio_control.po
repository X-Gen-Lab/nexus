# Chinese (Simplified) translations for Nexus.
# Copyright (C) 2026 Nexus Team
# This file is distributed under the same license as the Nexus project.
#
msgid ""
msgstr ""
"Project-Id-Version: PROJECT VERSION\n"
"Report-Msgid-Bugs-To: EMAIL@ADDRESS\n"
"POT-Creation-Date: 2026-01-25 10:45+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: zh_CN <LL@li.org>\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Generated-By: Babel 2.16.0\n"

#: ../../tutorials/gpio_control.rst:2 8c81d15c9f69435c881cd9649daa8b48
msgid "GPIO Control Tutorial"
msgstr "GPIO Control 教程"

#: ../../tutorials/gpio_control.rst:4 a4023de6feaf463599b1358fceb20a60
msgid ""
"This tutorial teaches you advanced GPIO control techniques using the Nexus "
"HAL. You'll learn how to read inputs, control outputs, handle interrupts, "
"and implement debouncing."
msgstr ""

#: ../../tutorials/gpio_control.rst:7 cc039c5f30e14b5eb8eb597c268aee4a
msgid "Learning Objectives"
msgstr "学习目标"

#: ../../tutorials/gpio_control.rst:9 4f3b4bf7b7c74efbbec8ec8d3f6d1c9c
msgid "By the end of this tutorial, you will:"
msgstr "完成本教程后，您将能够："

#: ../../tutorials/gpio_control.rst:11 e29ec503e1a24053990fc28823284ec8
msgid "Configure GPIO pins as inputs and outputs"
msgstr ""

#: ../../tutorials/gpio_control.rst:12 92b656fdf74f42d399696ac22a5b9857
msgid "Read button states with proper debouncing"
msgstr ""

#: ../../tutorials/gpio_control.rst:13 86f330c552cd4c6fb1f7b2545982f281
msgid "Use GPIO interrupts for event-driven programming"
msgstr ""

#: ../../tutorials/gpio_control.rst:14 00cafded4ef3473c92bbd6665190ec9d
msgid "Control multiple LEDs with patterns"
msgstr ""

#: ../../tutorials/gpio_control.rst:15 c23438a31a0e4e5a9f8e683404fa28ca
msgid "Understand GPIO electrical characteristics"
msgstr ""

#: ../../tutorials/gpio_control.rst:18 ca566cd5cbbd4113a218381c0754b92c
msgid "Prerequisites"
msgstr "前置条件"

#: ../../tutorials/gpio_control.rst:20 8b5b7a2be6e841989d7aa3e1d388dd43
msgid "Completed :doc:`first_application` tutorial"
msgstr ""

#: ../../tutorials/gpio_control.rst:21 02679e19bdc14f1e91aa98dc722272a5
msgid "STM32F4 Discovery board or compatible hardware"
msgstr "STM32F4 Discovery 板或兼容硬件"

#: ../../tutorials/gpio_control.rst:22 379f10df0d9f40b1a6796899be004d48
msgid "Basic understanding of digital I/O concepts"
msgstr ""

#: ../../tutorials/gpio_control.rst:25 a943d03aa3f24c0986e569ff6e3ce1d5
msgid "Hardware Setup"
msgstr "硬件设置"

#: ../../tutorials/gpio_control.rst:27 f93a19aa72b84dbc9c857189aa83364e
msgid "For this tutorial, you'll use:"
msgstr ""

#: ../../tutorials/gpio_control.rst:29 5bf0be13807d4f9d8ac59bb22c34f246
msgid "**Outputs (LEDs on STM32F4 Discovery):**"
msgstr "**Outputs (LEDs on STM32F4 Discovery):**"

#: ../../tutorials/gpio_control.rst:31 bc9f18fe41dc42fb964920e09101058d
msgid "PD12: Green LED"
msgstr ""

#: ../../tutorials/gpio_control.rst:32 479373fa43944081828cdbb35657576a
msgid "PD13: Orange LED"
msgstr ""

#: ../../tutorials/gpio_control.rst:33 6b178f8e72b046c99d74ef15d1b1cf16
msgid "PD14: Red LED"
msgstr ""

#: ../../tutorials/gpio_control.rst:34 13e968e56cc649c2a4fbf40db8b29877
msgid "PD15: Blue LED"
msgstr ""

#: ../../tutorials/gpio_control.rst:36 7d7f80b6e5c04cedb845fd392e1aaf2f
msgid "**Input (User Button):**"
msgstr "**Input (User Button):**"

#: ../../tutorials/gpio_control.rst:38 3a682f3bccbb475683213f1268690a06
msgid "PA0: User button (active high)"
msgstr "PA0: User button (active high)"

#: ../../tutorials/gpio_control.rst:40 aa8d383c876142d0a8e088e3d1fb8fa3
msgid "No additional wiring is required for the STM32F4 Discovery board."
msgstr ""

#: ../../tutorials/gpio_control.rst:43 c440e1cbc2454c71a70a06d0c23f53cb
msgid "Part 1: Reading GPIO Inputs"
msgstr ""

#: ../../tutorials/gpio_control.rst:45 ee6c28b77b8746b19257c7dc8cc1e0c8
msgid "Let's start by reading the user button state."
msgstr ""

#: ../../tutorials/gpio_control.rst:48 9b65dd1552cf4531ad6246e460e61ce1
msgid "GPIO Input Workflow"
msgstr ""

#: ../../tutorials/gpio_control.rst:50 94143f51a3a842fd9248e55db995c4d2
msgid ""
"The following diagram shows the workflow for reading GPIO inputs and "
"controlling outputs:"
msgstr ""

#: ../../tutorials/gpio_control.rst:80 a3f3981f584b43de821b96940a14c7a9
msgid "Basic Button Reading"
msgstr ""

#: ../../tutorials/gpio_control.rst:82 f5865099041449358d1f13eb4fde9b76
msgid ""
"#include \"hal/hal.h\"\n"
"\n"
"/* Button pin */\n"
"#define BTN_PORT    HAL_GPIO_PORT_A\n"
"#define BTN_PIN     0\n"
"\n"
"/* LED pin */\n"
"#define LED_PORT    HAL_GPIO_PORT_D\n"
"#define LED_PIN     12\n"
"\n"
"/**\n"
" * \\brief           Initialize button GPIO\n"
" */\n"
"static hal_status_t button_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_INPUT,\n"
"        .pull = HAL_GPIO_PULL_DOWN,  /* Pull-down for active-high button */\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,  /* Not used for input */\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    return hal_gpio_init(BTN_PORT, BTN_PIN, &config);\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Initialize LED GPIO\n"
" */\n"
"static hal_status_t led_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    return hal_gpio_init(LED_PORT, LED_PIN, &config);\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"    button_init();\n"
"    led_init();\n"
"\n"
"    while (1) {\n"
"        /* Read button state */\n"
"        hal_gpio_level_t button_state = hal_gpio_read(BTN_PORT, BTN_PIN);\n"
"\n"
"        /* Control LED based on button */\n"
"        if (button_state == HAL_GPIO_LEVEL_HIGH) {\n"
"            hal_gpio_write(LED_PORT, LED_PIN, HAL_GPIO_LEVEL_HIGH);\n"
"        } else {\n"
"            hal_gpio_write(LED_PORT, LED_PIN, HAL_GPIO_LEVEL_LOW);\n"
"        }\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"#include \"hal/hal.h\"\n"
"\n"
"/* Button pin */\n"
"#define BTN_PORT    HAL_GPIO_PORT_A\n"
"#define BTN_PIN     0\n"
"\n"
"/* LED pin */\n"
"#define LED_PORT    HAL_GPIO_PORT_D\n"
"#define LED_PIN     12\n"
"\n"
"/**\n"
" * \\brief           Initialize button GPIO\n"
" */\n"
"static hal_status_t button_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_INPUT,\n"
"        .pull = HAL_GPIO_PULL_DOWN,  /* Pull-down for active-high button */\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,  /* Not used for input */\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    return hal_gpio_init(BTN_PORT, BTN_PIN, &config);\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Initialize LED GPIO\n"
" */\n"
"static hal_status_t led_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    return hal_gpio_init(LED_PORT, LED_PIN, &config);\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"    button_init();\n"
"    led_init();\n"
"\n"
"    while (1) {\n"
"        /* Read button state */\n"
"        hal_gpio_level_t button_state = hal_gpio_read(BTN_PORT, BTN_PIN);\n"
"\n"
"        /* Control LED based on button */\n"
"        if (button_state == HAL_GPIO_LEVEL_HIGH) {\n"
"            hal_gpio_write(LED_PORT, LED_PIN, HAL_GPIO_LEVEL_HIGH);\n"
"        } else {\n"
"            hal_gpio_write(LED_PORT, LED_PIN, HAL_GPIO_LEVEL_LOW);\n"
"        }\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/gpio_control.rst:144 4d1dccea7f66468284e8441478cac16c
msgid "**Key Points:**"
msgstr "**Key Points:**"

#: ../../tutorials/gpio_control.rst:146 e15ed31c26a645a4981302cb2d1937fc
msgid "Use ``HAL_GPIO_DIR_INPUT`` for input pins"
msgstr ""

#: ../../tutorials/gpio_control.rst:147 c3e1df0f3a5d4ce8bdaa4bddaaac7216
msgid ""
"Configure pull resistors based on button type (pull-down for active-high, "
"pull-up for active-low)"
msgstr ""
"Configure pull resistors based on button type (pull-down for active-high, "
"pull-up for active-low)"

#: ../../tutorials/gpio_control.rst:148 feaccfc3d6f94de5a715f94c581f4f06
msgid ""
"``hal_gpio_read()`` returns ``HAL_GPIO_LEVEL_HIGH`` or "
"``HAL_GPIO_LEVEL_LOW``"
msgstr ""
"``hal_gpio_read()`` returns ``HAL_GPIO_LEVEL_HIGH`` or "
"``HAL_GPIO_LEVEL_LOW``"

#: ../../tutorials/gpio_control.rst:151 c02e436ab5c34ca08572cda264fe97d3
msgid "Button Debouncing"
msgstr ""

#: ../../tutorials/gpio_control.rst:153 a704d2e93fee4891b9c34c63f3f6c6d5
msgid ""
"Mechanical buttons can \"bounce\" when pressed, causing multiple "
"transitions. Here's how to debounce:"
msgstr ""

#: ../../tutorials/gpio_control.rst:155 b4b5987c38d94af3baae9e5db530035e
msgid ""
"#define DEBOUNCE_DELAY_MS  50\n"
"\n"
"/**\n"
" * \\brief           Read button with debouncing\n"
" * \\return          true if button is pressed (debounced)\n"
" */\n"
"static bool button_read_debounced(void) {\n"
"    static uint32_t last_change_time = 0;\n"
"    static bool last_stable_state = false;\n"
"\n"
"    /* Read current state */\n"
"    bool current_state = (hal_gpio_read(BTN_PORT, BTN_PIN) == HAL_GPIO_LEVEL_HIGH);\n"
"\n"
"    /* Check if state changed */\n"
"    if (current_state != last_stable_state) {\n"
"        uint32_t now = hal_get_tick();\n"
"\n"
"        /* Check if enough time has passed since last change */\n"
"        if ((now - last_change_time) >= DEBOUNCE_DELAY_MS) {\n"
"            last_stable_state = current_state;\n"
"            last_change_time = now;\n"
"        }\n"
"    }\n"
"\n"
"    return last_stable_state;\n"
"}\n"
"\n"
"/* Usage in main loop */\n"
"while (1) {\n"
"    if (button_read_debounced()) {\n"
"        hal_gpio_write(LED_PORT, LED_PIN, HAL_GPIO_LEVEL_HIGH);\n"
"    } else {\n"
"        hal_gpio_write(LED_PORT, LED_PIN, HAL_GPIO_LEVEL_LOW);\n"
"    }\n"
"\n"
"    hal_delay_ms(10);  /* Small delay to reduce CPU usage */\n"
"}"
msgstr ""
"#define DEBOUNCE_DELAY_MS  50\n"
"\n"
"/**\n"
" * \\brief           Read button with debouncing\n"
" * \\return          true if button is pressed (debounced)\n"
" */\n"
"static bool button_read_debounced(void) {\n"
"    static uint32_t last_change_time = 0;\n"
"    static bool last_stable_state = false;\n"
"\n"
"    /* Read current state */\n"
"    bool current_state = (hal_gpio_read(BTN_PORT, BTN_PIN) == HAL_GPIO_LEVEL_HIGH);\n"
"\n"
"    /* Check if state changed */\n"
"    if (current_state != last_stable_state) {\n"
"        uint32_t now = hal_get_tick();\n"
"\n"
"        /* Check if enough time has passed since last change */\n"
"        if ((now - last_change_time) >= DEBOUNCE_DELAY_MS) {\n"
"            last_stable_state = current_state;\n"
"            last_change_time = now;\n"
"        }\n"
"    }\n"
"\n"
"    return last_stable_state;\n"
"}\n"
"\n"
"/* Usage in main loop */\n"
"while (1) {\n"
"    if (button_read_debounced()) {\n"
"        hal_gpio_write(LED_PORT, LED_PIN, HAL_GPIO_LEVEL_HIGH);\n"
"    } else {\n"
"        hal_gpio_write(LED_PORT, LED_PIN, HAL_GPIO_LEVEL_LOW);\n"
"    }\n"
"\n"
"    hal_delay_ms(10);  /* Small delay to reduce CPU usage */\n"
"}"

#: ../../tutorials/gpio_control.rst:196 5aeaa2919a104990b717ec17897df78d
msgid "Edge Detection"
msgstr ""

#: ../../tutorials/gpio_control.rst:198 6d3135d4a56d4b2c8f77eefadaefe544
msgid "Detect button press and release events:"
msgstr ""

#: ../../tutorials/gpio_control.rst:200 4466d2e4b7ac4d6498352953fff308a1
msgid ""
"/**\n"
" * \\brief           Detect button edges\n"
" * \\param[out]      pressed: Set to true on press event\n"
" * \\param[out]      released: Set to true on release event\n"
" */\n"
"static void button_detect_edges(bool* pressed, bool* released) {\n"
"    static bool last_state = false;\n"
"    bool current_state = button_read_debounced();\n"
"\n"
"    *pressed = false;\n"
"    *released = false;\n"
"\n"
"    if (current_state && !last_state) {\n"
"        *pressed = true;  /* Rising edge */\n"
"    } else if (!current_state && last_state) {\n"
"        *released = true;  /* Falling edge */\n"
"    }\n"
"\n"
"    last_state = current_state;\n"
"}\n"
"\n"
"/* Usage */\n"
"while (1) {\n"
"    bool pressed, released;\n"
"    button_detect_edges(&pressed, &released);\n"
"\n"
"    if (pressed) {\n"
"        /* Button was just pressed */\n"
"        hal_gpio_toggle(LED_PORT, LED_PIN);\n"
"    }\n"
"\n"
"    hal_delay_ms(10);\n"
"}"
msgstr ""
"/**\n"
" * \\brief           Detect button edges\n"
" * \\param[out]      pressed: Set to true on press event\n"
" * \\param[out]      released: Set to true on release event\n"
" */\n"
"static void button_detect_edges(bool* pressed, bool* released) {\n"
"    static bool last_state = false;\n"
"    bool current_state = button_read_debounced();\n"
"\n"
"    *pressed = false;\n"
"    *released = false;\n"
"\n"
"    if (current_state && !last_state) {\n"
"        *pressed = true;  /* Rising edge */\n"
"    } else if (!current_state && last_state) {\n"
"        *released = true;  /* Falling edge */\n"
"    }\n"
"\n"
"    last_state = current_state;\n"
"}\n"
"\n"
"/* Usage */\n"
"while (1) {\n"
"    bool pressed, released;\n"
"    button_detect_edges(&pressed, &released);\n"
"\n"
"    if (pressed) {\n"
"        /* Button was just pressed */\n"
"        hal_gpio_toggle(LED_PORT, LED_PIN);\n"
"    }\n"
"\n"
"    hal_delay_ms(10);\n"
"}"

#: ../../tutorials/gpio_control.rst:237 b738ebf69c924b7e82f9950ec6bbc00c
msgid "Part 2: Advanced Output Control"
msgstr ""

#: ../../tutorials/gpio_control.rst:240 629090b489dc463fb26da741426ed790
msgid "LED Patterns"
msgstr ""

#: ../../tutorials/gpio_control.rst:242 d3062d2a34454b0097b5ef7a02c55d49
msgid "Create complex LED patterns:"
msgstr ""

#: ../../tutorials/gpio_control.rst:244 50a9c77aa06f4d7b834cbf19394e5148
msgid ""
"/* LED array for easy access */\n"
"typedef struct {\n"
"    hal_gpio_port_t port;\n"
"    hal_gpio_pin_t pin;\n"
"} led_t;\n"
"\n"
"static const led_t leds[] = {\n"
"    {HAL_GPIO_PORT_D, 12},  /* Green */\n"
"    {HAL_GPIO_PORT_D, 13},  /* Orange */\n"
"    {HAL_GPIO_PORT_D, 14},  /* Red */\n"
"    {HAL_GPIO_PORT_D, 15}   /* Blue */\n"
"};\n"
"\n"
"#define NUM_LEDS  (sizeof(leds) / sizeof(leds[0]))\n"
"\n"
"/**\n"
" * \\brief           Initialize all LEDs\n"
" */\n"
"static hal_status_t leds_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        if (hal_gpio_init(leds[i].port, leds[i].pin, &config) != HAL_OK) {\n"
"            return HAL_ERR_FAIL;\n"
"        }\n"
"    }\n"
"\n"
"    return HAL_OK;\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Set LED state\n"
" */\n"
"static void led_set(size_t index, bool on) {\n"
"    if (index < NUM_LEDS) {\n"
"        hal_gpio_write(leds[index].port, leds[index].pin,\n"
"                      on ? HAL_GPIO_LEVEL_HIGH : HAL_GPIO_LEVEL_LOW);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Turn off all LEDs\n"
" */\n"
"static void leds_all_off(void) {\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, false);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Knight Rider pattern\n"
" */\n"
"static void pattern_knight_rider(void) {\n"
"    /* Forward */\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, true);\n"
"        hal_delay_ms(100);\n"
"        led_set(i, false);\n"
"    }\n"
"\n"
"    /* Backward */\n"
"    for (int i = NUM_LEDS - 1; i >= 0; i--) {\n"
"        led_set(i, true);\n"
"        hal_delay_ms(100);\n"
"        led_set(i, false);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Binary counter pattern\n"
" */\n"
"static void pattern_binary_counter(void) {\n"
"    for (uint8_t count = 0; count < 16; count++) {\n"
"        for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"            led_set(i, (count & (1 << i)) != 0);\n"
"        }\n"
"        hal_delay_ms(500);\n"
"    }\n"
"}"
msgstr ""
"/* LED array for easy access */\n"
"typedef struct {\n"
"    hal_gpio_port_t port;\n"
"    hal_gpio_pin_t pin;\n"
"} led_t;\n"
"\n"
"static const led_t leds[] = {\n"
"    {HAL_GPIO_PORT_D, 12},  /* Green */\n"
"    {HAL_GPIO_PORT_D, 13},  /* Orange */\n"
"    {HAL_GPIO_PORT_D, 14},  /* Red */\n"
"    {HAL_GPIO_PORT_D, 15}   /* Blue */\n"
"};\n"
"\n"
"#define NUM_LEDS  (sizeof(leds) / sizeof(leds[0]))\n"
"\n"
"/**\n"
" * \\brief           Initialize all LEDs\n"
" */\n"
"static hal_status_t leds_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        if (hal_gpio_init(leds[i].port, leds[i].pin, &config) != HAL_OK) {\n"
"            return HAL_ERR_FAIL;\n"
"        }\n"
"    }\n"
"\n"
"    return HAL_OK;\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Set LED state\n"
" */\n"
"static void led_set(size_t index, bool on) {\n"
"    if (index < NUM_LEDS) {\n"
"        hal_gpio_write(leds[index].port, leds[index].pin,\n"
"                      on ? HAL_GPIO_LEVEL_HIGH : HAL_GPIO_LEVEL_LOW);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Turn off all LEDs\n"
" */\n"
"static void leds_all_off(void) {\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, false);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Knight Rider pattern\n"
" */\n"
"static void pattern_knight_rider(void) {\n"
"    /* Forward */\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, true);\n"
"        hal_delay_ms(100);\n"
"        led_set(i, false);\n"
"    }\n"
"\n"
"    /* Backward */\n"
"    for (int i = NUM_LEDS - 1; i >= 0; i--) {\n"
"        led_set(i, true);\n"
"        hal_delay_ms(100);\n"
"        led_set(i, false);\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Binary counter pattern\n"
" */\n"
"static void pattern_binary_counter(void) {\n"
"    for (uint8_t count = 0; count < 16; count++) {\n"
"        for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"            led_set(i, (count & (1 << i)) != 0);\n"
"        }\n"
"        hal_delay_ms(500);\n"
"    }\n"
"}"

#: ../../tutorials/gpio_control.rst:333 82508560d6594c3cb0be88eace9d8322
msgid "PWM-like LED Dimming"
msgstr ""

#: ../../tutorials/gpio_control.rst:335 63f380c4d84549c7bea380aee7cf684d
msgid "Create software PWM for LED dimming:"
msgstr ""

#: ../../tutorials/gpio_control.rst:337 342b2f4d8a9b4a38aa40ab9b3457e5e0
msgid ""
"/**\n"
" * \\brief           Set LED brightness (0-100%)\n"
" * \\param[in]       index: LED index\n"
" * \\param[in]       brightness: Brightness percentage (0-100)\n"
" */\n"
"static void led_set_brightness(size_t index, uint8_t brightness) {\n"
"    if (index >= NUM_LEDS || brightness > 100) {\n"
"        return;\n"
"    }\n"
"\n"
"    /* Software PWM: on_time / period = brightness / 100 */\n"
"    uint32_t period_us = 1000;  /* 1ms period = 1kHz */\n"
"    uint32_t on_time_us = (period_us * brightness) / 100;\n"
"    uint32_t off_time_us = period_us - on_time_us;\n"
"\n"
"    if (on_time_us > 0) {\n"
"        hal_gpio_write(leds[index].port, leds[index].pin, HAL_GPIO_LEVEL_HIGH);\n"
"        /* Note: hal_delay_us() would be needed for microsecond delays */\n"
"        /* For now, use millisecond approximation */\n"
"        if (on_time_us >= 1000) {\n"
"            hal_delay_ms(on_time_us / 1000);\n"
"        }\n"
"    }\n"
"\n"
"    if (off_time_us > 0) {\n"
"        hal_gpio_write(leds[index].port, leds[index].pin, HAL_GPIO_LEVEL_LOW);\n"
"        if (off_time_us >= 1000) {\n"
"            hal_delay_ms(off_time_us / 1000);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Fade LED in and out\n"
" */\n"
"static void pattern_fade(size_t led_index) {\n"
"    /* Fade in */\n"
"    for (uint8_t brightness = 0; brightness <= 100; brightness += 5) {\n"
"        for (int i = 0; i < 10; i++) {  /* Repeat for smooth appearance */\n"
"            led_set_brightness(led_index, brightness);\n"
"        }\n"
"    }\n"
"\n"
"    /* Fade out */\n"
"    for (uint8_t brightness = 100; brightness > 0; brightness -= 5) {\n"
"        for (int i = 0; i < 10; i++) {\n"
"            led_set_brightness(led_index, brightness);\n"
"        }\n"
"    }\n"
"}"
msgstr ""
"/**\n"
" * \\brief           Set LED brightness (0-100%)\n"
" * \\param[in]       index: LED index\n"
" * \\param[in]       brightness: Brightness percentage (0-100)\n"
" */\n"
"static void led_set_brightness(size_t index, uint8_t brightness) {\n"
"    if (index >= NUM_LEDS || brightness > 100) {\n"
"        return;\n"
"    }\n"
"\n"
"    /* Software PWM: on_time / period = brightness / 100 */\n"
"    uint32_t period_us = 1000;  /* 1ms period = 1kHz */\n"
"    uint32_t on_time_us = (period_us * brightness) / 100;\n"
"    uint32_t off_time_us = period_us - on_time_us;\n"
"\n"
"    if (on_time_us > 0) {\n"
"        hal_gpio_write(leds[index].port, leds[index].pin, HAL_GPIO_LEVEL_HIGH);\n"
"        /* Note: hal_delay_us() would be needed for microsecond delays */\n"
"        /* For now, use millisecond approximation */\n"
"        if (on_time_us >= 1000) {\n"
"            hal_delay_ms(on_time_us / 1000);\n"
"        }\n"
"    }\n"
"\n"
"    if (off_time_us > 0) {\n"
"        hal_gpio_write(leds[index].port, leds[index].pin, HAL_GPIO_LEVEL_LOW);\n"
"        if (off_time_us >= 1000) {\n"
"            hal_delay_ms(off_time_us / 1000);\n"
"        }\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Fade LED in and out\n"
" */\n"
"static void pattern_fade(size_t led_index) {\n"
"    /* Fade in */\n"
"    for (uint8_t brightness = 0; brightness <= 100; brightness += 5) {\n"
"        for (int i = 0; i < 10; i++) {  /* Repeat for smooth appearance */\n"
"            led_set_brightness(led_index, brightness);\n"
"        }\n"
"    }\n"
"\n"
"    /* Fade out */\n"
"    for (uint8_t brightness = 100; brightness > 0; brightness -= 5) {\n"
"        for (int i = 0; i < 10; i++) {\n"
"            led_set_brightness(led_index, brightness);\n"
"        }\n"
"    }\n"
"}"

#: ../../tutorials/gpio_control.rst:391 c8b5244597fa49d5b01c7b260243ff17
msgid "Part 3: GPIO Interrupts"
msgstr ""

#: ../../tutorials/gpio_control.rst:393 10d44807508c4044a60c62b49ed4695f
msgid "GPIO interrupts allow event-driven programming without polling."
msgstr ""

#: ../../tutorials/gpio_control.rst:396 e55272e1cf8942b38e6c1f8996d07d25
msgid ""
"GPIO interrupt support depends on the platform. Check your platform guide "
"for availability."
msgstr ""

#: ../../tutorials/gpio_control.rst:399 1e3627d3218e41a889bbd24e1319f17c
msgid "Configuring GPIO Interrupts"
msgstr ""

#: ../../tutorials/gpio_control.rst:401 0d4251fec58144f8b6417722a174cf81
msgid ""
"#include \"hal/hal.h\"\n"
"\n"
"static volatile bool button_pressed = false;\n"
"\n"
"/**\n"
" * \\brief           GPIO interrupt callback\n"
" * \\param[in]       port: GPIO port\n"
" * \\param[in]       pin: GPIO pin\n"
" */\n"
"static void gpio_interrupt_callback(hal_gpio_port_t port, hal_gpio_pin_t pin) {\n"
"    if (port == BTN_PORT && pin == BTN_PIN) {\n"
"        button_pressed = true;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Initialize button with interrupt\n"
" */\n"
"static hal_status_t button_init_interrupt(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_INPUT,\n"
"        .pull = HAL_GPIO_PULL_DOWN,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    /* Initialize GPIO */\n"
"    if (hal_gpio_init(BTN_PORT, BTN_PIN, &config) != HAL_OK) {\n"
"        return HAL_ERR_FAIL;\n"
"    }\n"
"\n"
"    /* Configure interrupt on rising edge */\n"
"    hal_gpio_irq_config_t irq_config = {\n"
"        .trigger = HAL_GPIO_IRQ_TRIGGER_RISING,\n"
"        .callback = gpio_interrupt_callback\n"
"    };\n"
"\n"
"    return hal_gpio_irq_init(BTN_PORT, BTN_PIN, &irq_config);\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"    button_init_interrupt();\n"
"    leds_init();\n"
"\n"
"    /* Enable GPIO interrupts */\n"
"    hal_gpio_irq_enable(BTN_PORT, BTN_PIN);\n"
"\n"
"    while (1) {\n"
"        /* Check flag set by interrupt */\n"
"        if (button_pressed) {\n"
"            button_pressed = false;  /* Clear flag */\n"
"\n"
"            /* Toggle LED */\n"
"            hal_gpio_toggle(LED_PORT, LED_PIN);\n"
"        }\n"
"\n"
"        /* CPU can sleep here to save power */\n"
"        hal_delay_ms(10);\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"#include \"hal/hal.h\"\n"
"\n"
"static volatile bool button_pressed = false;\n"
"\n"
"/**\n"
" * \\brief           GPIO interrupt callback\n"
" * \\param[in]       port: GPIO port\n"
" * \\param[in]       pin: GPIO pin\n"
" */\n"
"static void gpio_interrupt_callback(hal_gpio_port_t port, hal_gpio_pin_t pin) {\n"
"    if (port == BTN_PORT && pin == BTN_PIN) {\n"
"        button_pressed = true;\n"
"    }\n"
"}\n"
"\n"
"/**\n"
" * \\brief           Initialize button with interrupt\n"
" */\n"
"static hal_status_t button_init_interrupt(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_INPUT,\n"
"        .pull = HAL_GPIO_PULL_DOWN,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    /* Initialize GPIO */\n"
"    if (hal_gpio_init(BTN_PORT, BTN_PIN, &config) != HAL_OK) {\n"
"        return HAL_ERR_FAIL;\n"
"    }\n"
"\n"
"    /* Configure interrupt on rising edge */\n"
"    hal_gpio_irq_config_t irq_config = {\n"
"        .trigger = HAL_GPIO_IRQ_TRIGGER_RISING,\n"
"        .callback = gpio_interrupt_callback\n"
"    };\n"
"\n"
"    return hal_gpio_irq_init(BTN_PORT, BTN_PIN, &irq_config);\n"
"}\n"
"\n"
"int main(void) {\n"
"    hal_init();\n"
"    button_init_interrupt();\n"
"    leds_init();\n"
"\n"
"    /* Enable GPIO interrupts */\n"
"    hal_gpio_irq_enable(BTN_PORT, BTN_PIN);\n"
"\n"
"    while (1) {\n"
"        /* Check flag set by interrupt */\n"
"        if (button_pressed) {\n"
"            button_pressed = false;  /* Clear flag */\n"
"\n"
"            /* Toggle LED */\n"
"            hal_gpio_toggle(LED_PORT, LED_PIN);\n"
"        }\n"
"\n"
"        /* CPU can sleep here to save power */\n"
"        hal_delay_ms(10);\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/gpio_control.rst:468 15182849307e43d49b0b9a102e4ee042
msgid "**Interrupt Triggers:**"
msgstr "**Interrupt Triggers:**"

#: ../../tutorials/gpio_control.rst:470 3e5d062e844a4300835619aec472fd5c
msgid "``HAL_GPIO_IRQ_TRIGGER_RISING``: Trigger on low-to-high transition"
msgstr ""

#: ../../tutorials/gpio_control.rst:471 d4cca892a8624f8585a4f0a49476e713
msgid "``HAL_GPIO_IRQ_TRIGGER_FALLING``: Trigger on high-to-low transition"
msgstr ""

#: ../../tutorials/gpio_control.rst:472 84dcc34846a9430590fd3377de1580af
msgid "``HAL_GPIO_IRQ_TRIGGER_BOTH``: Trigger on any edge"
msgstr ""

#: ../../tutorials/gpio_control.rst:474 abfcdf0d793e425a803a8735fc9b0475
msgid "**Important Notes:**"
msgstr "**Important Notes:**"

#: ../../tutorials/gpio_control.rst:476 dd465437578c431aa2447d38d4f07ce1
msgid "Keep interrupt handlers short and fast"
msgstr ""

#: ../../tutorials/gpio_control.rst:477 6adf37504d394e0abad920e2c2d243ed
msgid "Use volatile for variables shared between interrupt and main code"
msgstr ""

#: ../../tutorials/gpio_control.rst:478 8d53772a63524ccb89918916749ff1ce
msgid "Avoid calling blocking functions in interrupt handlers"
msgstr ""

#: ../../tutorials/gpio_control.rst:479 d9a500e2d4b842e4b7fa7f96151a6a51
msgid "Consider using a flag to signal the main loop"
msgstr ""

#: ../../tutorials/gpio_control.rst:482 d9ebdd39411e4d4b87e692962a5da1af
msgid "Part 4: Complete Example"
msgstr ""

#: ../../tutorials/gpio_control.rst:484 5c5c864d51344f5ab7e87fdf56069952
msgid "Here's a complete example combining all concepts:"
msgstr ""

#: ../../tutorials/gpio_control.rst:486 10216894f90c4455b5803f89d5bf7179
msgid ""
"/**\n"
" * \\file            gpio_demo.c\n"
" * \\brief           GPIO Control Demo\n"
" */\n"
"\n"
"#include \"hal/hal.h\"\n"
"#include <stdbool.h>\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Configuration                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"#define BTN_PORT    HAL_GPIO_PORT_A\n"
"#define BTN_PIN     0\n"
"\n"
"#define DEBOUNCE_DELAY_MS  50\n"
"\n"
"typedef struct {\n"
"    hal_gpio_port_t port;\n"
"    hal_gpio_pin_t pin;\n"
"} led_t;\n"
"\n"
"static const led_t leds[] = {\n"
"    {HAL_GPIO_PORT_D, 12},  /* Green */\n"
"    {HAL_GPIO_PORT_D, 13},  /* Orange */\n"
"    {HAL_GPIO_PORT_D, 14},  /* Red */\n"
"    {HAL_GPIO_PORT_D, 15}   /* Blue */\n"
"};\n"
"\n"
"#define NUM_LEDS  (sizeof(leds) / sizeof(leds[0]))\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* State Machine                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"typedef enum {\n"
"    MODE_OFF,\n"
"    MODE_SINGLE_BLINK,\n"
"    MODE_KNIGHT_RIDER,\n"
"    MODE_BINARY_COUNTER,\n"
"    MODE_MAX\n"
"} led_mode_t;\n"
"\n"
"static led_mode_t current_mode = MODE_OFF;\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Helper Functions                                                      */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static hal_status_t leds_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        if (hal_gpio_init(leds[i].port, leds[i].pin, &config) != HAL_OK) {\n"
"            return HAL_ERR_FAIL;\n"
"        }\n"
"    }\n"
"    return HAL_OK;\n"
"}\n"
"\n"
"static hal_status_t button_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_INPUT,\n"
"        .pull = HAL_GPIO_PULL_DOWN,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    return hal_gpio_init(BTN_PORT, BTN_PIN, &config);\n"
"}\n"
"\n"
"static void led_set(size_t index, bool on) {\n"
"    if (index < NUM_LEDS) {\n"
"        hal_gpio_write(leds[index].port, leds[index].pin,\n"
"                      on ? HAL_GPIO_LEVEL_HIGH : HAL_GPIO_LEVEL_LOW);\n"
"    }\n"
"}\n"
"\n"
"static void leds_all_off(void) {\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, false);\n"
"    }\n"
"}\n"
"\n"
"static bool button_read_debounced(void) {\n"
"    static uint32_t last_change_time = 0;\n"
"    static bool last_stable_state = false;\n"
"\n"
"    bool current_state = (hal_gpio_read(BTN_PORT, BTN_PIN) == HAL_GPIO_LEVEL_HIGH);\n"
"\n"
"    if (current_state != last_stable_state) {\n"
"        uint32_t now = hal_get_tick();\n"
"        if ((now - last_change_time) >= DEBOUNCE_DELAY_MS) {\n"
"            last_stable_state = current_state;\n"
"            last_change_time = now;\n"
"        }\n"
"    }\n"
"\n"
"    return last_stable_state;\n"
"}\n"
"\n"
"static bool button_pressed_event(void) {\n"
"    static bool last_state = false;\n"
"    bool current_state = button_read_debounced();\n"
"    bool pressed = current_state && !last_state;\n"
"    last_state = current_state;\n"
"    return pressed;\n"
"}\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* LED Patterns                                                          */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static void mode_single_blink(void) {\n"
"    led_set(0, true);\n"
"    hal_delay_ms(500);\n"
"    led_set(0, false);\n"
"    hal_delay_ms(500);\n"
"}\n"
"\n"
"static void mode_knight_rider(void) {\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, true);\n"
"        hal_delay_ms(100);\n"
"        led_set(i, false);\n"
"    }\n"
"    for (int i = NUM_LEDS - 1; i >= 0; i--) {\n"
"        led_set(i, true);\n"
"        hal_delay_ms(100);\n"
"        led_set(i, false);\n"
"    }\n"
"}\n"
"\n"
"static void mode_binary_counter(void) {\n"
"    static uint8_t count = 0;\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, (count & (1 << i)) != 0);\n"
"    }\n"
"    count++;\n"
"    hal_delay_ms(500);\n"
"}\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Main Function                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"int main(void) {\n"
"    /* Initialize */\n"
"    hal_init();\n"
"    leds_init();\n"
"    button_init();\n"
"\n"
"    /* Main loop */\n"
"    while (1) {\n"
"        /* Check for button press to change mode */\n"
"        if (button_pressed_event()) {\n"
"            current_mode = (current_mode + 1) % MODE_MAX;\n"
"            leds_all_off();\n"
"        }\n"
"\n"
"        /* Execute current mode */\n"
"        switch (current_mode) {\n"
"            case MODE_OFF:\n"
"                leds_all_off();\n"
"                hal_delay_ms(100);\n"
"                break;\n"
"\n"
"            case MODE_SINGLE_BLINK:\n"
"                mode_single_blink();\n"
"                break;\n"
"\n"
"            case MODE_KNIGHT_RIDER:\n"
"                mode_knight_rider();\n"
"                break;\n"
"\n"
"            case MODE_BINARY_COUNTER:\n"
"                mode_binary_counter();\n"
"                break;\n"
"\n"
"            default:\n"
"                current_mode = MODE_OFF;\n"
"                break;\n"
"        }\n"
"    }\n"
"\n"
"    return 0;\n"
"}"
msgstr ""
"/**\n"
" * \\file            gpio_demo.c\n"
" * \\brief           GPIO Control Demo\n"
" */\n"
"\n"
"#include \"hal/hal.h\"\n"
"#include <stdbool.h>\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Configuration                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"#define BTN_PORT    HAL_GPIO_PORT_A\n"
"#define BTN_PIN     0\n"
"\n"
"#define DEBOUNCE_DELAY_MS  50\n"
"\n"
"typedef struct {\n"
"    hal_gpio_port_t port;\n"
"    hal_gpio_pin_t pin;\n"
"} led_t;\n"
"\n"
"static const led_t leds[] = {\n"
"    {HAL_GPIO_PORT_D, 12},  /* Green */\n"
"    {HAL_GPIO_PORT_D, 13},  /* Orange */\n"
"    {HAL_GPIO_PORT_D, 14},  /* Red */\n"
"    {HAL_GPIO_PORT_D, 15}   /* Blue */\n"
"};\n"
"\n"
"#define NUM_LEDS  (sizeof(leds) / sizeof(leds[0]))\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* State Machine                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"typedef enum {\n"
"    MODE_OFF,\n"
"    MODE_SINGLE_BLINK,\n"
"    MODE_KNIGHT_RIDER,\n"
"    MODE_BINARY_COUNTER,\n"
"    MODE_MAX\n"
"} led_mode_t;\n"
"\n"
"static led_mode_t current_mode = MODE_OFF;\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Helper Functions                                                      */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static hal_status_t leds_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_OUTPUT,\n"
"        .pull = HAL_GPIO_PULL_NONE,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        if (hal_gpio_init(leds[i].port, leds[i].pin, &config) != HAL_OK) {\n"
"            return HAL_ERR_FAIL;\n"
"        }\n"
"    }\n"
"    return HAL_OK;\n"
"}\n"
"\n"
"static hal_status_t button_init(void) {\n"
"    hal_gpio_config_t config = {\n"
"        .direction = HAL_GPIO_DIR_INPUT,\n"
"        .pull = HAL_GPIO_PULL_DOWN,\n"
"        .output_mode = HAL_GPIO_OUTPUT_PP,\n"
"        .speed = HAL_GPIO_SPEED_LOW,\n"
"        .init_level = HAL_GPIO_LEVEL_LOW\n"
"    };\n"
"    return hal_gpio_init(BTN_PORT, BTN_PIN, &config);\n"
"}\n"
"\n"
"static void led_set(size_t index, bool on) {\n"
"    if (index < NUM_LEDS) {\n"
"        hal_gpio_write(leds[index].port, leds[index].pin,\n"
"                      on ? HAL_GPIO_LEVEL_HIGH : HAL_GPIO_LEVEL_LOW);\n"
"    }\n"
"}\n"
"\n"
"static void leds_all_off(void) {\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, false);\n"
"    }\n"
"}\n"
"\n"
"static bool button_read_debounced(void) {\n"
"    static uint32_t last_change_time = 0;\n"
"    static bool last_stable_state = false;\n"
"\n"
"    bool current_state = (hal_gpio_read(BTN_PORT, BTN_PIN) == HAL_GPIO_LEVEL_HIGH);\n"
"\n"
"    if (current_state != last_stable_state) {\n"
"        uint32_t now = hal_get_tick();\n"
"        if ((now - last_change_time) >= DEBOUNCE_DELAY_MS) {\n"
"            last_stable_state = current_state;\n"
"            last_change_time = now;\n"
"        }\n"
"    }\n"
"\n"
"    return last_stable_state;\n"
"}\n"
"\n"
"static bool button_pressed_event(void) {\n"
"    static bool last_state = false;\n"
"    bool current_state = button_read_debounced();\n"
"    bool pressed = current_state && !last_state;\n"
"    last_state = current_state;\n"
"    return pressed;\n"
"}\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* LED Patterns                                                          */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"static void mode_single_blink(void) {\n"
"    led_set(0, true);\n"
"    hal_delay_ms(500);\n"
"    led_set(0, false);\n"
"    hal_delay_ms(500);\n"
"}\n"
"\n"
"static void mode_knight_rider(void) {\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, true);\n"
"        hal_delay_ms(100);\n"
"        led_set(i, false);\n"
"    }\n"
"    for (int i = NUM_LEDS - 1; i >= 0; i--) {\n"
"        led_set(i, true);\n"
"        hal_delay_ms(100);\n"
"        led_set(i, false);\n"
"    }\n"
"}\n"
"\n"
"static void mode_binary_counter(void) {\n"
"    static uint8_t count = 0;\n"
"    for (size_t i = 0; i < NUM_LEDS; i++) {\n"
"        led_set(i, (count & (1 << i)) != 0);\n"
"    }\n"
"    count++;\n"
"    hal_delay_ms(500);\n"
"}\n"
"\n"
"/*-----------------------------------------------------------------------*/\n"
"/* Main Function                                                         */\n"
"/*-----------------------------------------------------------------------*/\n"
"\n"
"int main(void) {\n"
"    /* Initialize */\n"
"    hal_init();\n"
"    leds_init();\n"
"    button_init();\n"
"\n"
"    /* Main loop */\n"
"    while (1) {\n"
"        /* Check for button press to change mode */\n"
"        if (button_pressed_event()) {\n"
"            current_mode = (current_mode + 1) % MODE_MAX;\n"
"            leds_all_off();\n"
"        }\n"
"\n"
"        /* Execute current mode */\n"
"        switch (current_mode) {\n"
"            case MODE_OFF:\n"
"                leds_all_off();\n"
"                hal_delay_ms(100);\n"
"                break;\n"
"\n"
"            case MODE_SINGLE_BLINK:\n"
"                mode_single_blink();\n"
"                break;\n"
"\n"
"            case MODE_KNIGHT_RIDER:\n"
"                mode_knight_rider();\n"
"                break;\n"
"\n"
"            case MODE_BINARY_COUNTER:\n"
"                mode_binary_counter();\n"
"                break;\n"
"\n"
"            default:\n"
"                current_mode = MODE_OFF;\n"
"                break;\n"
"        }\n"
"    }\n"
"\n"
"    return 0;\n"
"}"

#: ../../tutorials/gpio_control.rst:682 c1cc3267541242ee92a8b70c99151888
msgid "**How It Works:**"
msgstr "**How It Works:**"

#: ../../tutorials/gpio_control.rst:684 a0cf4e7677b64be280eb5777d0e96393
msgid "Press the button to cycle through modes"
msgstr ""

#: ../../tutorials/gpio_control.rst:685 1d5f82d3d5b940779e9afd63ca6ca938
msgid "Mode 0: All LEDs off"
msgstr ""

#: ../../tutorials/gpio_control.rst:686 8f6b651572554f2eaae68e5ba4685534
msgid "Mode 1: Single LED blinks"
msgstr ""

#: ../../tutorials/gpio_control.rst:687 93f9a1745fc14d878702813e77831bdd
msgid "Mode 2: Knight Rider pattern"
msgstr ""

#: ../../tutorials/gpio_control.rst:688 de4874c3a7a44f5eae23412754386530
msgid "Mode 3: Binary counter (0-15)"
msgstr "Mode 3: Binary counter (0-15)"

#: ../../tutorials/gpio_control.rst:691 b5f2b1562b86439ea6a85b707497d69c
msgid "Best Practices"
msgstr "最佳实践"

#: ../../tutorials/gpio_control.rst:693 860364eeb9944aa28634c51312be9186
msgid "**Always Initialize**: Call ``hal_init()`` before using GPIO functions"
msgstr ""
"**Always Initialize**: Call ``hal_init()`` before using GPIO functions"

#: ../../tutorials/gpio_control.rst:695 7cf61250bb8b4232800608a4ea3bcfd7
msgid "**Check Return Values**: Always check return values from HAL functions"
msgstr ""

#: ../../tutorials/gpio_control.rst:697 629014e7370f4168b020c41d02155e84
msgid ""
"**Use Appropriate Pull Resistors**: Configure pull-up/down based on your "
"circuit"
msgstr ""

#: ../../tutorials/gpio_control.rst:699 127ec66a403f4c58898292c167b1483a
msgid "**Debounce Inputs**: Always debounce mechanical switches"
msgstr ""

#: ../../tutorials/gpio_control.rst:701 432f53cf05a4453d84e307398533b660
msgid "**Keep Interrupts Short**: Minimize work in interrupt handlers"
msgstr ""

#: ../../tutorials/gpio_control.rst:703 1be86ef1cbcc4dd6adf5023aa618a00f
msgid ""
"**Use Appropriate Speed**: Don't use high-speed GPIO for slow signals "
"(wastes power)"
msgstr ""
"**Use Appropriate Speed**: Don't use high-speed GPIO for slow signals "
"(wastes power)"

#: ../../tutorials/gpio_control.rst:705 b8ae8c261d9c4f53be88254c558cc215
msgid ""
"**Document Pin Assignments**: Clearly document which pins are used for what"
msgstr ""

#: ../../tutorials/gpio_control.rst:708 02585d4bda2b45e39e13c96efbdc95e5
msgid "Common Pitfalls"
msgstr ""

#: ../../tutorials/gpio_control.rst:710 09110218a6c54d1ba0e623b811dc2ca4
msgid "**Forgetting Pull Resistors:**"
msgstr "**Forgetting Pull Resistors:**"

#: ../../tutorials/gpio_control.rst:712 4097a62f0f634ff8bcd491849b97cd33
msgid ""
"Floating inputs can cause erratic behavior. Always configure pull resistors "
"for inputs."
msgstr ""

#: ../../tutorials/gpio_control.rst:714 3e5ea893e01345b8b83aa0570d82b2b9
msgid "**No Debouncing:**"
msgstr "**No Debouncing:**"

#: ../../tutorials/gpio_control.rst:716 72ea8c42b02b43d9b16a035869b252b1
msgid ""
"Mechanical switches bounce. Always implement debouncing for reliable "
"operation."
msgstr ""

#: ../../tutorials/gpio_control.rst:718 48d3415e0f1c4b7fae05412973963cf7
msgid "**Blocking in Interrupts:**"
msgstr "**Blocking in Interrupts:**"

#: ../../tutorials/gpio_control.rst:720 3fc2d0498934435f93946f2e534b032a
msgid ""
"Never call ``hal_delay_ms()`` or other blocking functions in interrupt "
"handlers."
msgstr ""
"Never call ``hal_delay_ms()`` or other blocking functions in interrupt "
"handlers."

#: ../../tutorials/gpio_control.rst:722 c3f58cc6109746238066dba62cdc3289
msgid "**Wrong Trigger Type:**"
msgstr "**Wrong Trigger Type:**"

#: ../../tutorials/gpio_control.rst:724 8f326a486cab4d2e92bfb70013ebcb6b
msgid ""
"Choose the correct interrupt trigger (rising, falling, or both) for your "
"application."
msgstr ""
"Choose the correct interrupt trigger (rising, falling, or both) for your "
"application."

#: ../../tutorials/gpio_control.rst:727 77406c0e766542729d4823441d8a1219
msgid "Next Steps"
msgstr "下一步"

#: ../../tutorials/gpio_control.rst:729 65412f8413a84efc9e24b271ce1a252c
msgid ":doc:`uart_communication` - Add serial communication"
msgstr ":doc:`uart_communication` - Add serial communication"

#: ../../tutorials/gpio_control.rst:730 e153f120c2e34823b488f2eaa2cea30e
msgid ":doc:`task_creation` - Use OSAL for multi-tasking"
msgstr ":doc:`task_creation` - Use OSAL for multi-tasking"

#: ../../tutorials/gpio_control.rst:731 12f09a517f75478a90ddef2d8fd5b5d7
msgid ":doc:`../user_guide/hal` - Explore more HAL features"
msgstr ":doc:`../user_guide/hal` - Explore more HAL features"

#: ../../tutorials/gpio_control.rst:732 9d67c5ad599b4c5bbca1824beab2ec97
msgid ":doc:`../platform_guides/stm32f4` - Platform-specific GPIO details"
msgstr ":doc:`../platform_guides/stm32f4` - Platform-specific GPIO details"
